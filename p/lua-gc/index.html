<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Lua GC ：三色标记、增量回收与写屏障 在上一篇文章中，我们探讨了 Lua 的数据结构（TValue）以及哪些对象是值类型，哪些是引用类型。今天，我们继续向下挖掘，聊聊 Lua 虚拟机中的垃圾回收机制（Garbage Collection）。\n"><title>Lua GC</title><link rel=canonical href=https://WeissGoat.github.io/WBlog/p/lua-gc/><link rel=stylesheet href=/WBlog/scss/style.min.51098b80cc297c94c0f57786d4a04e7372774e5993b60facf53870128a79bf73.css><meta property='og:title' content="Lua GC"><meta property='og:description' content="Lua GC ：三色标记、增量回收与写屏障 在上一篇文章中，我们探讨了 Lua 的数据结构（TValue）以及哪些对象是值类型，哪些是引用类型。今天，我们继续向下挖掘，聊聊 Lua 虚拟机中的垃圾回收机制（Garbage Collection）。\n"><meta property='og:url' content='https://WeissGoat.github.io/WBlog/p/lua-gc/'><meta property='og:site_name' content='白山羊'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Lua'><meta property='article:tag' content='GC'><meta property='article:published_time' content='2024-02-05T18:00:00+08:00'><meta property='article:modified_time' content='2024-02-05T18:00:00+08:00'><meta name=twitter:title content="Lua GC"><meta name=twitter:description content="Lua GC ：三色标记、增量回收与写屏障 在上一篇文章中，我们探讨了 Lua 的数据结构（TValue）以及哪些对象是值类型，哪些是引用类型。今天，我们继续向下挖掘，聊聊 Lua 虚拟机中的垃圾回收机制（Garbage Collection）。\n"><link rel="shortcut icon" href=https://WeissGoat.github.io/WBlog/img/avatar.jpg></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/WBlog/><img src=https://WeissGoat.github.io/WBlog/img/avatar.jpg width height class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/WBlog/>白山羊</a></h1><h2 class=site-description>To be continued...</h2></div></header><ol class=menu-social><li><a href=https://github.com/whitessheep target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/WBlog/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/WBlog/%E5%85%B3%E4%BA%8E/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li><a href=/WBlog/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/WBlog/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav class=toc-nav id=TableOfContents><ol><li><a href=#从-stop-the-world-到增量>从 Stop-the-World 到增量</a><ol><li><a href=#lua-50简单的代价>Lua 5.0：简单的代价</a></li><li><a href=#lua-51三色增量标记tri-color-incremental-mark--sweep>Lua 5.1+：三色增量标记（Tri-color Incremental Mark & Sweep）</a></li></ol></li><li><a href=#核心算法三色标记与双白设计>核心算法：三色标记与双白设计</a><ol><li><a href=#颜色的含义>颜色的含义</a></li><li><a href=#巧妙的双白设计-the-two-whites>巧妙的“双白”设计 (The Two Whites)</a></li></ol></li><li><a href=#状态机的流转gc-的生命周期>状态机的流转：GC 的生命周期</a><ol><li><a href=#-gcspause-暂停初始化>① GCSpause (暂停/初始化)</a></li><li><a href=#-gcspropagate-传播---最耗时的阶段>② GCSpropagate (传播 - 最耗时的阶段)</a></li><li><a href=#-gcsatomic-原子阶段---必须一次做完>③ GCSatomic (原子阶段 - 必须一次做完)</a></li><li><a href=#-gcssweepstring-字符串清理>④ GCSsweepstring (字符串清理)</a></li><li><a href=#-gcssweep-普通对象清理>⑤ GCSsweep (普通对象清理)</a></li><li><a href=#-gcsfinalize-终结>⑥ GCSfinalize (终结)</a></li></ol></li><li><a href=#并发下的黑指向白与写屏障>并发下的“黑指向白”与写屏障</a><ol><li><a href=#解决方案写屏障-write-barrier>解决方案：写屏障 (Write Barrier)</a><ol><li><a href=#1-前进屏障-forward-barrier---把白色染灰>1. 前进屏障 (Forward Barrier) - &ldquo;把白色染灰&rdquo;</a></li><li><a href=#2-后退屏障-backward-barrier---把黑色回退变灰>2. 后退屏障 (Backward Barrier) - &ldquo;把黑色回退变灰&rdquo;</a></li></ol></li><li><a href=#源码窥探>源码窥探</a></li></ol></li><li><a href=#gc触发的时机>GC触发的时机</a></li><li><a href=#控制-gc-的速率>控制 GC 的速率</a><ol><li><a href=#pause-暂停系数><code>pause</code> (暂停系数)</a></li><li><a href=#stepmul-步进倍率><code>stepmul</code> (步进倍率)</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/WBlog/categories/lua/ style=background-color:#efbeca;color:#3d0f1b>Lua</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/WBlog/p/lua-gc/>Lua GC</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2024-02-05T18:00:00+08:00>2024年2月5日星期一</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 7 分钟</time></div></footer></div></header><aside class=article-toc><details><summary><div class=article-toc-title><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-chevron-right"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 6l6 6-6 6"/></svg>
<span>目录</span></div></summary><nav class=toc-nav><ol><li><a href=#从-stop-the-world-到增量>从 Stop-the-World 到增量</a><ol><li><a href=#lua-50简单的代价>Lua 5.0：简单的代价</a></li><li><a href=#lua-51三色增量标记tri-color-incremental-mark--sweep>Lua 5.1+：三色增量标记（Tri-color Incremental Mark & Sweep）</a></li></ol></li><li><a href=#核心算法三色标记与双白设计>核心算法：三色标记与双白设计</a><ol><li><a href=#颜色的含义>颜色的含义</a></li><li><a href=#巧妙的双白设计-the-two-whites>巧妙的“双白”设计 (The Two Whites)</a></li></ol></li><li><a href=#状态机的流转gc-的生命周期>状态机的流转：GC 的生命周期</a><ol><li><a href=#-gcspause-暂停初始化>① GCSpause (暂停/初始化)</a></li><li><a href=#-gcspropagate-传播---最耗时的阶段>② GCSpropagate (传播 - 最耗时的阶段)</a></li><li><a href=#-gcsatomic-原子阶段---必须一次做完>③ GCSatomic (原子阶段 - 必须一次做完)</a></li><li><a href=#-gcssweepstring-字符串清理>④ GCSsweepstring (字符串清理)</a></li><li><a href=#-gcssweep-普通对象清理>⑤ GCSsweep (普通对象清理)</a></li><li><a href=#-gcsfinalize-终结>⑥ GCSfinalize (终结)</a></li></ol></li><li><a href=#并发下的黑指向白与写屏障>并发下的“黑指向白”与写屏障</a><ol><li><a href=#解决方案写屏障-write-barrier>解决方案：写屏障 (Write Barrier)</a><ol><li><a href=#1-前进屏障-forward-barrier---把白色染灰>1. 前进屏障 (Forward Barrier) - &ldquo;把白色染灰&rdquo;</a></li><li><a href=#2-后退屏障-backward-barrier---把黑色回退变灰>2. 后退屏障 (Backward Barrier) - &ldquo;把黑色回退变灰&rdquo;</a></li></ol></li><li><a href=#源码窥探>源码窥探</a></li></ol></li><li><a href=#gc触发的时机>GC触发的时机</a></li><li><a href=#控制-gc-的速率>控制 GC 的速率</a><ol><li><a href=#pause-暂停系数><code>pause</code> (暂停系数)</a></li><li><a href=#stepmul-步进倍率><code>stepmul</code> (步进倍率)</a></li></ol></li></ol></nav></details></aside><section class=article-content><h1 id=lua-gc-三色标记增量回收与写屏障>Lua GC ：三色标记、增量回收与写屏障</h1><p>在上一篇文章中，我们探讨了 Lua 的数据结构（<code>TValue</code>）以及哪些对象是值类型，哪些是引用类型。今天，我们继续向下挖掘，聊聊 Lua 虚拟机中的<strong>垃圾回收机制（Garbage Collection）</strong>。</p><h2 id=从-stop-the-world-到增量>从 Stop-the-World 到增量</h2><h3 id=lua-50简单的代价>Lua 5.0：简单的代价</h3><p>在 Lua 5.0 时代，GC 算法非常朴素：<strong>双倍阈值，全量回收</strong>。</p><ul><li><strong>逻辑</strong>：当内存使用量达到上次 GC 后的两倍时，虚拟机暂停所有业务逻辑，跑一遍完整的“标记-清除”。</li><li><strong>后果</strong>：这就是著名的 <strong>Stop-the-World (STW)</strong>。如果你的 Lua 内存占用了 1GB，GC 触发的那一瞬间，整个游戏或服务可能会卡顿几百毫秒甚至更久。</li></ul><h3 id=lua-51三色增量标记tri-color-incremental-mark--sweep>Lua 5.1+：三色增量标记（Tri-color Incremental Mark & Sweep）</h3><p>为了解决卡顿，Lua 5.1 引入了增量 GC。GC 过程与业务代码交替运行。</p><p>为了实现“可中断、可恢复”的扫描，Lua 引入了<strong>三色标记法</strong>。</p><h2 id=核心算法三色标记与双白设计>核心算法：三色标记与双白设计</h2><p>GC 的本质是从根节点（_G、Registry、栈）出发，找到所有可达对象。在增量扫描过程中，对象被标记为三种颜色：</p><h3 id=颜色的含义>颜色的含义</h3><ul><li><strong>⚪ 白色 (White)</strong>：</li><li><strong>含义</strong>：当前还未被 GC 访问到的对象，或者已死亡的对象。</li><li><strong>初始状态</strong>：所有新创建的对象默认为白色。</li><li><strong>结局</strong>：如果 GC 结束后还是白色，说明不可达，<strong>回收</strong>。</li><li><strong>⚫ 黑色 (Black)</strong>：</li><li><strong>含义</strong>：<strong>已扫描完毕</strong>。该对象及其引用的所有子对象都已经被访问过了。</li><li><strong>特性</strong>：GC 这一轮不会再回头看它。</li><li><strong>🔘 灰色 (Gray)</strong>：</li><li><strong>含义</strong>：<strong>待处理</strong>。该对象已被访问（从白色变成了灰色），但它引用的子对象还没扫描完。</li><li><strong>作用</strong>：灰色是当前扫描的边缘（Frontier），保存在一个链表中。</li></ul><h3 id=巧妙的双白设计-the-two-whites>巧妙的“双白”设计 (The Two Whites)</h3><p>我在研究源码时发现一个有趣的细节：Lua 的白色其实细分为 <strong>White1</strong> 和 <strong>White2</strong>。这是为了解决什么问题？</p><p><strong>场景</strong>： GC 标记阶段已经快结束了（大部分是黑色），此时业务代码突然创建了一个新对象。</p><ol><li>新对象默认是<strong>白色</strong>。</li><li>如果不加区分，在接下来的“清除阶段”，GC 会认为这个白色的新对象是“没被引用的垃圾”并把它回收掉——<strong>这会导致严重 Bug</strong>。</li></ol><p><strong>解决方案</strong>： Lua 使用一个全局的位掩码 <code>CurrentWhite</code>。</p><ul><li><strong>本轮 GC</strong>：只回收标记为“旧白色”的对象。</li><li><strong>新创建对象</strong>：标记为“新白色”（CurrentWhite）。</li><li><strong>结果</strong>：新对象在本轮 GC 中被视为“安全”，留到下一轮再处理。在清除阶段结束后，Lua 会轮转 <code>CurrentWhite</code> 的值。</li></ul><h2 id=状态机的流转gc-的生命周期>状态机的流转：GC 的生命周期</h2><p>Lua 的增量 GC 是通过一个状态机驱动的。每次调用 <code>luaC_step</code>，GC 就会向前推进一步。以下是主要的阶段：</p><h3 id=-gcspause-暂停初始化>① GCSpause (暂停/初始化)</h3><p>GC 的起点。</p><ul><li>将根节点（主线程、全局表 _G、Registry 等）标记为<strong>灰色</strong>，并加入灰色链表。</li><li>此时，通过根节点的一波操作，我们有了第一批待扫描的灰色对象。</li></ul><h3 id=-gcspropagate-传播---最耗时的阶段>② GCSpropagate (传播 - 最耗时的阶段)</h3><p>这是“增量”体现最明显的地方。</p><ul><li><strong>操作</strong>：从灰色链表中弹出一个对象，将其标记为<strong>黑色</strong>，然后遍历它引用的所有子对象：</li><li>如果是白色，将其染成<strong>灰色</strong>并加入链表。</li><li><strong>控制</strong>：这个过程不是一次性做完的，而是受 <code>gcstepmul</code> 控制，每次只处理一部分就暂停，把 CPU 让给业务逻辑。</li></ul><h3 id=-gcsatomic-原子阶段---必须一次做完>③ GCSatomic (原子阶段 - 必须一次做完)</h3><p>这是这一轮 GC 中唯一需要 Stop-the-World 的时刻，但通常很快。</p><ul><li><strong>目的</strong>：因为 Propagate 阶段是并发的，业务代码可能在此期间修改了引用（比如把一个白色对象赋值给了一个已经黑色的 Table）。如果不修正，那个白色对象会被误删。</li><li><strong>操作</strong>：</li></ul><ol><li>重新遍历“灰名单”（GrayAgain，由写屏障产生，详见下文）。</li><li>扫描弱引用表（Weak Tables）。</li><li>完成所有剩余的标记工作。</li></ol><h3 id=-gcssweepstring-字符串清理>④ GCSsweepstring (字符串清理)</h3><ul><li><strong>特点</strong>：Lua 的短字符串是单独管理的（通常存储在全局哈希表中）。因为字符串没有子引用，清理非常快，直接从哈希表中移除未标记的字符串。</li></ul><h3 id=-gcssweep-普通对象清理>⑤ GCSsweep (普通对象清理)</h3><ul><li><strong>操作</strong>：遍历所有 GCObject 链表。</li><li>如果是<strong>黑色</strong>：说明活着，重置为当前白色（为下一轮做准备）。</li><li>如果是<strong>旧白色</strong>：说明死了，<strong>free</strong> 掉内存。</li></ul><h3 id=-gcsfinalize-终结>⑥ GCSfinalize (终结)</h3><ul><li>处理所有实现了 <code>__gc</code> 元方法的 Userdata。这些对象不会立即释放，而是会被放入一个单独的列表，等待虚拟机调用它们的析构函数。</li></ul><h2 id=并发下的黑指向白与写屏障>并发下的“黑指向白”与写屏障</h2><p>在 <code>GCSpropagate</code> 阶段，GC 和业务逻辑是交替运行的。这就带来了一个严重的<strong>数据竞争</strong>问题。</p><p><strong>问题场景</strong>：</p><ol><li>GC 标记了 Table A 为<strong>黑色</strong>（认为 A 已经扫描完了）。</li><li>业务代码执行 <code>A.x = B</code>，其中 B 是一个<strong>白色</strong>对象。</li><li>因为 A 已经是黑色，GC 不会再扫描它。</li><li><strong>后果</strong>：B 作为一个被引用的对象，却因为没被扫描到，保持白色。在清除阶段，B 会被当垃圾回收，导致 <code>A.x</code> 变成了野指针！</li></ol><h3 id=解决方案写屏障-write-barrier>解决方案：写屏障 (Write Barrier)</h3><p>为了维护**“黑色对象不能指向白色对象”**这一不变量（Invariant），Lua 在每次修改引用（table set/assignment）时，会触发写屏障。</p><p>写屏障有两种主要形式：</p><h4 id=1-前进屏障-forward-barrier---把白色染灰>1. 前进屏障 (Forward Barrier) - &ldquo;把白色染灰&rdquo;</h4><p>如果你把白色对象 B 赋给黑色对象 A，屏障会立即把 <strong>B 染成灰色</strong>。</p><ul><li><strong>意义</strong>：既然 A 引用了 B，那 B 肯定是有用的，赶紧把 B 拉进待扫描清单。</li><li><strong>应用</strong>：通常用于将新对象赋值给老对象时。用于 Closure (Upvalues)、Userdata 等。因为这些对象通常不像 Table 那样频繁修改引用。</li></ul><h4 id=2-后退屏障-backward-barrier---把黑色回退变灰>2. 后退屏障 (Backward Barrier) - &ldquo;把黑色回退变灰&rdquo;</h4><p>如果你把白色对象 B 赋给黑色对象 A，屏障把 <strong>A 变回灰色</strong>，扔进 <code>grayagain</code> 列表。</p><ul><li><strong>意义</strong>：A 你虽然扫过了，但你现在又有了新欢，GC 稍后得回头再查你一次。</li><li><strong>应用</strong>：通常用于 <code>Table</code> 等容器。这是因为 Table 容易频繁变动，如果用前进屏障（把子对象变灰），下次 Table 再变动时又要触发屏障；而把 Table 变灰后，它就留在 Gray 链表中，之后再往里面塞白色对象就不需要触发屏障了（因为父对象已经是灰的了）。</li></ul><h3 id=源码窥探>源码窥探</h3><p>让我们看看 Lua 内部宏 <code>luaC_barrier</code> 的简化逻辑：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* 伪代码逻辑：写屏障 */
</span></span><span class=line><span class=cl>#define luaC_barrier(L, p, v) {  \
</span></span><span class=line><span class=cl>    /* p 是父对象(Table)，v 是子对象(Value) */ \
</span></span><span class=line><span class=cl>    if (isblack(p) &amp;&amp; iswhite(v)) { \
</span></span><span class=line><span class=cl>        /* 触发屏障：黑色指向了白色 */ \
</span></span><span class=line><span class=cl>        luaC_barrier_(L, obj2gco(p), obj2gco(v)); \
</span></span><span class=line><span class=cl>    } \
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void luaC_barrier_ (lua_State *L, GCObject *p, GCObject *v) {
</span></span><span class=line><span class=cl>    /* 保持黑白不变性 */
</span></span><span class=line><span class=cl>    if (isdead(L, v)) return; // 已经死的不管
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    // 策略：通常是将 v (子对象) 标灰 (Forward Barrier)
</span></span><span class=line><span class=cl>    // 或者将 p (父对象) 放入 grayagain 列表 (Backward Barrier)
</span></span><span class=line><span class=cl>    reallymarkobject(L, v); 
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>正是这个 <code>luaC_barrier</code>，保证了增量 GC 的正确性。它就像一个监视器，拦截了所有的赋值操作。</p><h2 id=gc触发的时机>GC触发的时机</h2><p>假设我们执行以下代码：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>local i = 1234
</span></span></code></pre></td></tr></table></div></div><p>这行代码会触发 GC 吗？答案是<strong>不会</strong>。</p><p>根据 Lua 的内存模型（如上文 <code>TValue</code> 结构所示）：</p><ul><li><strong>值类型（Value Types）</strong>：如 <code>nil</code>, <code>boolean</code>, <code>number</code> (integer/float)。这些数据直接存放在 Lua 栈的 <code>TValue</code> 结构体中。它们随着栈帧的销毁而自动消失，<strong>不涉及堆内存分配</strong>（malloc），因此不计入 GC 的债务（GCdebt），自然也不会触发 GC 步进。</li><li><strong>引用类型（Reference Types）</strong>：如 <code>table</code>, <code>function</code>, <code>string</code> (长字符串), <code>userdata</code>。这些对象存活在堆上，才是 GC 主要“追杀”的目标。</li></ul><p>在 Lua 虚拟机源码中，几乎所有涉及内存分配的操作（如 <code>lua_newtable</code>, <code>lua_pushstring</code>）之后，都会调用一个检查宏：<strong><code>luaC_checkGC</code></strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>#define luaC_checkGC(L)  { \
</span></span><span class=line><span class=cl>    if (G(L)-&gt;GCdebt &gt; 0) { \
</span></span><span class=line><span class=cl>        luaC_step(L); \
</span></span><span class=line><span class=cl>    } \
</span></span><span class=line><span class=cl>    condchangemem(L,pre,pos); \
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li><strong><code>GCdebt</code> (GC 债务)</strong>：这是一个核心概念。每当你分配 1 字节内存，<code>GCdebt</code> 就会增加 1。</li><li><strong>判断逻辑</strong>：只要“债务”大于 0，Lua 就会认为“如果你制造了垃圾（或者申请了新内存），你就得负责清理一点垃圾”。</li><li><strong><code>luaC_step</code></strong>：这就是执行一次 GC“步进”的函数。它不会跑完整个 GC 流程，而是只跑一小步（具体跑多远，由 <code>stepmul</code> 决定）。</li></ul><h2 id=控制-gc-的速率>控制 GC 的速率</h2><p>了解了原理，我们就能看懂 <code>collectgarbage</code> 的两个参数了：</p><h3 id=pause-暂停系数><code>pause</code> (暂停系数)</h3><ul><li><strong>含义</strong>：GC的间歇率, 将 GCdebt 设置为一个巨大的负数来实现的, 默认值200（即 200%）。</li><li><strong>逻辑</strong>：如果当前内存是 10MB，GC 结束后回收到 5MB。那么下一次 GC 启动的阈值是 <code>5MB * 200% = 10MB</code>。</li><li>值越小，GC 越勤快，内存占用越低，但 CPU 消耗越高。</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>static void setpause (global_State *g) {
</span></span><span class=line><span class=cl>  l_mem threshold, debt;
</span></span><span class=line><span class=cl>  l_mem estimate = g-&gt;GCestimate / 100;  // 获取估算内存
</span></span><span class=line><span class=cl>  l_mem pause = (g-&gt;gcpause != 0) ? g-&gt;gcpause : 200; // 默认 200
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  /* 计算我们要等待多少内存分配 */
</span></span><span class=line><span class=cl>  threshold = (pause * estimate); 
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl>  /* 设置债务 = 估算值 - 阈值 
</span></span><span class=line><span class=cl>     因为 阈值 通常 &gt; 估算值，所以这里 debt 是负数
</span></span><span class=line><span class=cl>  */
</span></span><span class=line><span class=cl>  debt = gettotalbytes(g) - threshold; 
</span></span><span class=line><span class=cl>  luaE_setdebt(g, debt);
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h3 id=stepmul-步进倍率><code>stepmul</code> (步进倍率)</h3><ul><li><strong>含义</strong>：控制 GC 扫描的速度。默认值 200(200%)。</li><li><strong>逻辑</strong>：分配了 1 字节内存（增加了 1 字节债务）,GC 需要执行等同于 2 字节内存的工作量，才能把这 1 字节的债务“抵消”掉。</li><li>如果你发现内存飙升得比 GC 回收得快（Alloc > Free），说明 GC 跑慢了，需要<strong>调大</strong> <code>stepmul</code>。</li><li>如果你发现游戏明显卡顿，可能是 GC 一次步进占用 CPU 太多，尝试<strong>调小</strong> <code>stepmul</code> 让切片更细。</li></ul></section><footer class=article-footer><section class=article-tags><a href=/WBlog/tags/lua/>Lua</a>
<a href=/WBlog/tags/gc/>GC</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>true</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=[".main-article",".widget--toc"];e.forEach(e=>{const t=document.querySelector(e);t&&renderMathInElement(t,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})})</script></article><aside class=related-content--wrapper><h2 class=section-title>相关文章</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/WBlog/p/lua-table/><div class=article-details><h2 class=article-title>Lua Table</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2026 白山羊</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=4.0.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><script type=module>
    import gallery from '\/WBlog\/ts\/gallery.js';

    const articleContent = document.querySelector('.article-content');
    const shouldLoad = articleContent && (articleContent.querySelectorAll('figure').length > 0 || articleContent.querySelectorAll('img.gallery-image').length > 0);
    
    if (shouldLoad) {
        gallery(articleContent);

        const PhotoSwipeLightbox = (await import("https:\/\/cdn.jsdelivr.net\/npm\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js")).default;
        const styleHref = "https:\/\/cdn.jsdelivr.net\/npm\/photoswipe@5.4.4\/dist\/photoswipe.css";

        const styleTag = document.createElement('link');
        styleTag.rel = 'stylesheet';
        styleTag.href = styleHref;
        document.head.appendChild(styleTag);

        const lightbox = new PhotoSwipeLightbox({
            gallerySelector: '.article-content',
            childSelector: 'figure a.image-link',
            pswpModule: () => import("https:\/\/cdn.jsdelivr.net\/npm\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js")
        });
        lightbox.init();
    }
</script></main></div><script type=text/javascript src=/WBlog/ts/main.acaf849f2b273f6a8368a58b001f336738d0c948d92e79b116467d0c7515f932.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>