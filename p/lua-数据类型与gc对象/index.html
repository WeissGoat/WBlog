<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='Lua 源码手记：数据类型与隐藏的 GC 对象 最近在啃 Lua 的源码，主要想搞清楚一个问题：当我们写下 local a = 1 随后又写 a = "hello" 时，Lua 虚拟机底层到底发生了什么？\n'><title>Lua 数据类型与GC对象</title><link rel=canonical href=https://WeissGoat.github.io/WBlog/p/lua-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8Egc%E5%AF%B9%E8%B1%A1/><link rel=stylesheet href=/WBlog/scss/style.min.51098b80cc297c94c0f57786d4a04e7372774e5993b60facf53870128a79bf73.css><meta property='og:title' content="Lua 数据类型与GC对象"><meta property='og:description' content='Lua 源码手记：数据类型与隐藏的 GC 对象 最近在啃 Lua 的源码，主要想搞清楚一个问题：当我们写下 local a = 1 随后又写 a = "hello" 时，Lua 虚拟机底层到底发生了什么？\n'><meta property='og:url' content='https://WeissGoat.github.io/WBlog/p/lua-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8Egc%E5%AF%B9%E8%B1%A1/'><meta property='og:site_name' content='白山羊'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='lua'><meta property='article:published_time' content='2024-02-05T18:00:00+08:00'><meta property='article:modified_time' content='2024-02-05T18:00:00+08:00'><meta name=twitter:title content="Lua 数据类型与GC对象"><meta name=twitter:description content='Lua 源码手记：数据类型与隐藏的 GC 对象 最近在啃 Lua 的源码，主要想搞清楚一个问题：当我们写下 local a = 1 随后又写 a = "hello" 时，Lua 虚拟机底层到底发生了什么？\n'><link rel="shortcut icon" href=https://WeissGoat.github.io/WBlog/img/avatar.jpg></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label=切换菜单>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/WBlog/><img src=https://WeissGoat.github.io/WBlog/img/avatar.jpg width height class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/WBlog/>白山羊</a></h1><h2 class=site-description>To be continued...</h2></div></header><ol class=menu-social><li><a href=https://github.com/whitessheep target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/WBlog/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>主页</span></a></li><li><a href=/WBlog/%E5%85%B3%E4%BA%8E/><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>关于</span></a></li><li><a href=/WBlog/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>归档</span></a></li><li><a href=/WBlog/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>搜索</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>暗色模式</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">目录</h2><div class=widget--toc><nav class=toc-nav id=TableOfContents><ol><li><a href=#一-源码揭秘万物之容器-tvalue>一、 源码揭秘：万物之容器 TValue</a><ol><li><a href=#11-核心结构定义>1.1 核心结构定义</a></li><li><a href=#12-它是如何工作的>1.2 它是如何工作的？</a></li></ol></li><li><a href=#二-lua-的-8-种基本数据类型内存视角>二、 Lua 的 8 种基本数据类型：内存视角</a><ol><li><a href=#1-值类型-value-types--栈上的原住民>1. 值类型 (Value Types) —— 栈上的原住民</a></li><li><a href=#2-gc-类型-gcobjects--堆上的住客>2. GC 类型 (GCObjects) —— 堆上的住客</a></li></ol></li><li><a href=#三-谁在参与-gc内存管理揭秘>三、 谁在参与 GC？（内存管理揭秘）</a><ol><li><a href=#31-gcobject-的秘密>3.1 GCObject 的秘密</a></li><li><a href=#32-区分标准>3.2 区分标准</a></li></ol></li><li><a href=#四-隐形的-gc-对象proto-与-upval>四、 隐形的 GC 对象：Proto 与 UpVal</a><ol><li><a href=#1-proto-函数原型--静态的蓝图>1. Proto (函数原型) —— 静态的蓝图</a></li><li><a href=#2-upval-上值对象--闭包的灵魂>2. UpVal (上值对象) —— 闭包的灵魂</a></li></ol></li><li><a href=#五-总结与性能建议>五、 总结与性能建议</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/WBlog/categories/lua/ style=background-color:#efbeca;color:#3d0f1b>Lua</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/WBlog/p/lua-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8Egc%E5%AF%B9%E8%B1%A1/>Lua 数据类型与GC对象</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published datetime=2024-02-05T18:00:00+08:00>2024年2月5日星期一</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>阅读时长: 6 分钟</time></div></footer></div></header><aside class=article-toc><details><summary><div class=article-toc-title><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-chevron-right"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 6l6 6-6 6"/></svg>
<span>目录</span></div></summary><nav class=toc-nav><ol><li><a href=#一-源码揭秘万物之容器-tvalue>一、 源码揭秘：万物之容器 TValue</a><ol><li><a href=#11-核心结构定义>1.1 核心结构定义</a></li><li><a href=#12-它是如何工作的>1.2 它是如何工作的？</a></li></ol></li><li><a href=#二-lua-的-8-种基本数据类型内存视角>二、 Lua 的 8 种基本数据类型：内存视角</a><ol><li><a href=#1-值类型-value-types--栈上的原住民>1. 值类型 (Value Types) —— 栈上的原住民</a></li><li><a href=#2-gc-类型-gcobjects--堆上的住客>2. GC 类型 (GCObjects) —— 堆上的住客</a></li></ol></li><li><a href=#三-谁在参与-gc内存管理揭秘>三、 谁在参与 GC？（内存管理揭秘）</a><ol><li><a href=#31-gcobject-的秘密>3.1 GCObject 的秘密</a></li><li><a href=#32-区分标准>3.2 区分标准</a></li></ol></li><li><a href=#四-隐形的-gc-对象proto-与-upval>四、 隐形的 GC 对象：Proto 与 UpVal</a><ol><li><a href=#1-proto-函数原型--静态的蓝图>1. Proto (函数原型) —— 静态的蓝图</a></li><li><a href=#2-upval-上值对象--闭包的灵魂>2. UpVal (上值对象) —— 闭包的灵魂</a></li></ol></li><li><a href=#五-总结与性能建议>五、 总结与性能建议</a></li></ol></nav></details></aside><section class=article-content><h1 id=lua-源码手记数据类型与隐藏的-gc-对象>Lua 源码手记：数据类型与隐藏的 GC 对象</h1><p>最近在啃 Lua 的源码，主要想搞清楚一个问题：当我们写下 <code>local a = 1</code> 随后又写 <code>a = "hello"</code> 时，Lua 虚拟机底层到底发生了什么？</p><p>作为一个 Lua 开发者，我们习惯了“变量无类型，值有类型”的自由。但在 C 语言编写的虚拟机底层，内存是严苛且静态的。Lua 是如何在一个静态的 C 结构体中塞进千变万化的动态类型的？哪些数据是“活”在栈上的，哪些又是需要垃圾回收器（GC）费心照顾的？</p><p>本文将带你通过“显微镜”视角，从底层的 <code>TValue</code> 结构开始，重新审视 Lua 的数据类型系统与内存管理策略。</p><h2 id=一-源码揭秘万物之容器-tvalue>一、 源码揭秘：万物之容器 TValue</h2><p>在 Lua 虚拟机中，并没有“整数变量”或“字符串变量”的概念。无论是全局变量、局部变量，还是 Table 中的一个槽位，在底层 C 源码中，它们都由一个统一的数据结构表示：<strong><code>TValue</code></strong>。</p><p><code>TValue</code> 的设计完美体现了 Lua 的核心哲学：<strong>Tagged Union（带标签的联合体）</strong>。</p><h3 id=11-核心结构定义>1.1 核心结构定义</h3><p>我们可以将 <code>TValue</code> 想象成一个标准化的“通用快递盒”，它由两部分组成：</p><ol><li><strong>标签 (Tag)</strong>：说明书，标记盒子里装的是什么类型。</li><li><strong>值 (Value)</strong>：实际货物，或者指向货物的取货单（指针）。</li></ol><p>让我们看看 Lua 5.3+ 源码中的核心定义（位于 <code>lobject.h</code>）：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* 通用值联合体：同一时间只能存一种数据，保证内存紧凑 */
</span></span><span class=line><span class=cl>typedef union Value {
</span></span><span class=line><span class=cl>  GCObject *gc;    /* collectable objects: 复杂对象（Table, String...）存指针 -&gt; 指向堆内存 */
</span></span><span class=line><span class=cl>  void *p;         /* light userdata: 存纯指针 -&gt; 直接存地址 */
</span></span><span class=line><span class=cl>  int b;           /* boolean: 存 0 或 1 -&gt; 直接存整数 */
</span></span><span class=line><span class=cl>  lua_CFunction f; /* light C functions: 轻量级 C 函数 */
</span></span><span class=line><span class=cl>  lua_Integer i;   /* integer numbers: 整数 */
</span></span><span class=line><span class=cl>  lua_Number n;    /* float numbers: 浮点数 */
</span></span><span class=line><span class=cl>} Value;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/* Lua 中的通用值结构 */
</span></span><span class=line><span class=cl>#define TValuefields  Value value_; int tt_
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>typedef struct TValue {
</span></span><span class=line><span class=cl>  TValuefields;
</span></span><span class=line><span class=cl>} TValue;
</span></span></code></pre></td></tr></table></div></div><h3 id=12-它是如何工作的>1.2 它是如何工作的？</h3><p>当你写 <code>local a = 10</code> 时，Lua 虚拟机做的事情是：</p><ol><li>找到 <code>a</code> 对应的栈槽位（一个 <code>TValue</code> 内存块）。</li><li>将 <code>tt_</code> (标签) 设为 <code>LUA_TNUMINT</code>。</li><li>将 <code>value_.i</code> (数据) 设为 <code>10</code>。</li></ol><p>当你随后写 <code>a = {}</code> 时：</p><ol><li>虚拟机在<strong>堆内存</strong>中创建一个新的 Table 对象。</li><li>将 <code>a</code> 的 <code>tt_</code> 更新为 <code>LUA_TTABLE</code>。</li><li>将 <code>value_.gc</code> 更新为指向那个 Table 的指针。</li></ol><p>这种设计使得 Lua 的变量可以承载任何类型，因为它们本质上只是一个携带了类型标签的容器。</p><h2 id=二-lua-的-8-种基本数据类型内存视角>二、 Lua 的 8 种基本数据类型：内存视角</h2><p>基于 <code>TValue</code> 的存储方式，我们可以将 Lua 暴露给开发者的 8 种数据类型分为三大类。这直接关系到赋值操作的性能和 GC 的压力。</p><h3 id=1-值类型-value-types--栈上的原住民>1. 值类型 (Value Types) —— 栈上的原住民</h3><p>这些类型的数据非常小，直接存储在 <code>TValue</code> 结构体内部。</p><ul><li><strong>nil (空)</strong>：表示“无效值”。全局变量默认值。赋值 <code>nil</code> 等同于删除。</li><li><strong>boolean (布尔)</strong>：只有 <code>true</code> 和 <code>false</code>。</li><li><em>注意</em>：Lua 中只有 <code>false</code> 和 <code>nil</code> 为假，数字 <code>0</code> 是真。</li><li><strong>number (数值)</strong>：</li><li>Lua 5.3+ 分为 Integer (64位整型) 和 Float (双精度浮点)。</li><li>VM 会自动处理转换，通常无需感知。</li><li><strong>light userdata (轻量用户数据)</strong>：</li><li><strong>特例</strong>：它本质上是一个纯粹的 C 指针 (<code>void *</code>)。Lua 把它当作一个数字处理，<strong>不管理</strong>它的生命周期（生死由 C 端代码负责）。这是高性能交互的利器。</li></ul><h3 id=2-gc-类型-gcobjects--堆上的住客>2. GC 类型 (GCObjects) —— 堆上的住客</h3><p>这些类型数据量大且结构复杂，<code>TValue</code> 只存指针（<code>value_.gc</code>）。</p><ul><li><strong>string (字符串)</strong>：</li><li>不可变字符序列。</li><li><strong>String Interning (字符串驻留)</strong>：Lua 会对短字符串进行唯一化处理，相同内容的短字符串在全局只有一份内存，比较时只需比较指针地址，速度极快。</li><li><strong>table (表)</strong>：</li><li>Lua 唯一的数据结构。</li><li>既是数组（Array，下标从1开始），也是字典（Hash Map）。</li><li><strong>function (函数)</strong>：</li><li>第一类值（First-class）。</li><li>包含 C 函数和 Lua 函数（闭包）。</li><li><strong>thread (线程)</strong>：</li><li>协程 (Coroutine) 的实现基础。</li><li><strong>userdata (完全用户数据)</strong>：</li><li>由 Lua 虚拟机分配内存的一块原始内存区域，支持 <code>__gc</code> 元方法析构。</li></ul><h2 id=三-谁在参与-gc内存管理揭秘>三、 谁在参与 GC？（内存管理揭秘）</h2><p>在 Lua 中，并不是所有变量都需要垃圾回收器（Garbage Collection, GC）操心。</p><h3 id=31-gcobject-的秘密>3.1 GCObject 的秘密</h3><p>所有需要被 GC 管理的对象，在 C 层面都有一个共同的头部，叫做 <code>CommonHeader</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>/* 所有 GC 对象通用的头部 */
</span></span><span class=line><span class=cl>#define CommonHeader	GCObject *next; lu_byte tt; lu_byte marked
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct GCObject {
</span></span><span class=line><span class=cl>  CommonHeader;  /* 包含：链表指针、类型标签、GC 颜色标记 */
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><p>这就解释了为什么 Lua 可以统一管理不同类型的对象：因为它们强转为 <code>GCObject*</code> 后，头部结构是一样的，GC 只需要扫描这个头部链表即可。</p><h3 id=32-区分标准>3.2 区分标准</h3><ul><li><strong>不参与 GC</strong>：<code>nil</code>, <code>boolean</code>, <code>number</code>, <code>light userdata</code>。它们随栈帧生灭，无需 GC 介入。</li><li><strong>参与 GC</strong>：<code>string</code>, <code>table</code>, <code>function</code>, <code>userdata</code>, <code>thread</code>。它们在堆上分配，需要通过标记-清除（Mark-and-Sweep）算法回收。</li></ul><h2 id=四-隐形的-gc-对象proto-与-upval>四、 隐形的 GC 对象：Proto 与 UpVal</h2><p>除了上述我们在 Lua 代码中能直接操作的类型外，Lua 虚拟机底层还有两个非常关键的内部对象也是由 GC 管理的。<strong>理解它们，是掌握 Lua 闭包 (Closure) 机制的钥匙。</strong></p><h3 id=1-proto-函数原型--静态的蓝图>1. Proto (函数原型) —— 静态的蓝图</h3><p>你可以把 <code>Proto</code> 看作是**“函数的编译模具”**。</p><ul><li><strong>它是什么</strong>：当 Lua 编译器编译一段代码时，生成的字节码（Bytecode）、常量表（Constants）、调试信息等<strong>静态数据</strong>，都被打包存储在一个 <code>Proto</code> 对象中。</li><li><strong>生命周期</strong>：虽然它是静态的，但当你使用 <code>load</code> 加载一段代码块时，系统会生成对应的 <code>Proto</code>。如果这个模块被卸载，或者没有任何闭包再使用这个模具，<code>Proto</code> 就需要被回收。</li></ul><h3 id=2-upval-上值对象--闭包的灵魂>2. UpVal (上值对象) —— 闭包的灵魂</h3><p>这是 Lua 闭包机制最精妙的地方。<code>UpVal</code> 是独立于函数栈帧存在的对象，用于存储闭包捕获的外部局部变量。</p><ul><li><strong>为什么需要它？</strong> 当一个函数返回时，它的栈帧会被销毁，原本存在栈上的局部变量也就消失了。如果内部函数（闭包）还引用了这个变量，怎么办？</li><li><strong>Open vs Closed 状态</strong>：</li><li><strong>Open (开放)</strong>：当父函数还在运行时，被捕获的变量还在栈上。此时 <code>UpVal</code> 只是一个指针，指向栈上的那个位置。</li><li><strong>Closed (关闭)</strong>：当父函数返回，栈即将销毁时，Lua 会将变量的值<strong>复制</strong>到 <code>UpVal</code> 对象内部（堆内存），并将 <code>UpVal</code> 指针指向自己。这就实现了“变量逃逸”。</li></ul><p><strong>公式类比：</strong></p><blockquote><p><strong>Lua Function (运行时闭包) = Proto (静态代码逻辑) + UpVals (动态环境上下文)</strong></p></blockquote><p>这就是为什么两个闭包可以使用同一份代码（同一个 Proto），却拥有不同的状态（不同的 UpVals）。</p><h2 id=五-总结与性能建议>五、 总结与性能建议</h2><p>通过重新审视 <code>TValue</code> 和 GC 对象，我们可以得出一些写出高性能 Lua 代码的原则：</p><ol><li><strong>赋值开销</strong>：</li></ol><ul><li><code>number/boolean</code> 赋值是内存拷贝（极快）。</li><li><code>table/function</code> 赋值是指针拷贝（极快）。</li><li><strong>但是</strong>，创建 <code>table</code> (<code>{}</code>) 或闭包 (<code>function() end</code>) 是堆内存分配，相对较慢。</li></ul><ol start=2><li><strong>Light Userdata 的妙用</strong>： 如果你只需要在 Lua 里持有一个 C++ 对象的句柄，且生命周期由 C++ 管理，请务必使用 <code>light userdata</code>。它可以完全避开 GC 的扫描和追踪开销。</li><li><strong>闭包的代价</strong>： 每创建一个新的闭包，不仅会创建一个 <code>Function</code> 对象，如果涉及新的外部变量捕获，还可能创建新的 <code>UpVal</code> 对象。在极高频调用的场景下（如游戏每帧 Update），应尽量避免在循环内创建匿名函数。</li><li><strong>GC 压力</strong>： 字符串拼接（产生新 String 对象）和表的频繁创建销毁是 GC 卡顿的两大元凶。在性能敏感区，复用 Table（Object Pooling）永远是王道。</li></ol></section><footer class=article-footer><section class=article-tags><a href=/WBlog/tags/lua/>Lua</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>true</span></section></footer><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css integrity=sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js integrity=sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8 crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymous defer></script><script>window.addEventListener("DOMContentLoaded",()=>{const e=[".main-article",".widget--toc"];e.forEach(e=>{const t=document.querySelector(e);t&&renderMathInElement(t,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1},{left:"\\[",right:"\\]",display:!0}],ignoredClasses:["gist"]})})})</script></article><footer class=site-footer><section class=copyright>&copy;
2020 -
2026 白山羊</section><section class=powerby>使用 <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> 构建<br>主题 <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=4.0.0>Stack</a></b> 由 <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a> 设计</section></footer><script type=module>
    import gallery from '\/WBlog\/ts\/gallery.js';

    const articleContent = document.querySelector('.article-content');
    const shouldLoad = articleContent && (articleContent.querySelectorAll('figure').length > 0 || articleContent.querySelectorAll('img.gallery-image').length > 0);
    
    if (shouldLoad) {
        gallery(articleContent);

        const PhotoSwipeLightbox = (await import("https:\/\/cdn.jsdelivr.net\/npm\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js")).default;
        const styleHref = "https:\/\/cdn.jsdelivr.net\/npm\/photoswipe@5.4.4\/dist\/photoswipe.css";

        const styleTag = document.createElement('link');
        styleTag.rel = 'stylesheet';
        styleTag.href = styleHref;
        document.head.appendChild(styleTag);

        const lightbox = new PhotoSwipeLightbox({
            gallerySelector: '.article-content',
            childSelector: 'figure a.image-link',
            pswpModule: () => import("https:\/\/cdn.jsdelivr.net\/npm\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js")
        });
        lightbox.init();
    }
</script></main></div><script type=text/javascript src=/WBlog/ts/main.acaf849f2b273f6a8368a58b001f336738d0c948d92e79b116467d0c7515f932.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>