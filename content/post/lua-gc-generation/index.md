---
date: '2026-02-08T18:32:29+08:00'
draft: true
title: 'Lua 分代 GC'
image: ""
math: true
license: true
hidden: false
comments: true
categories:
    - "lua"
tags:
    - "lua"
    - "GC"
---
# 分代 GC：分代回收的回归与“两轮变老”机制

在之前的文章中，我们剖析了 Lua 经典的“三色标记”和“增量回收”算法。这套机制非常稳健，但在某些特定场景下——比如每帧创建大量临时 `Vector3` 的游戏逻辑中——它显得有点“太勤奋”了：明明大部分对象转瞬即逝，GC 却还得把整个内存扫描一遍才能确认它们死亡。

为了解决这个问题，Lua 5.4 正式引入了（或者说重新设计了）**分代 GC（Generational GC）**。

本文将结合 Lua 的发展历史，探讨分代 GC 的设计哲学、Lua 5.2 掉过的坑，以及 Lua 5.4 是如何通过“两轮变老”机制实现高效回收的。

## 核心假设：大部分对象都是“短命鬼”

分代 GC 的理论基础是一个在计算机科学中被反复验证的现象——**弱分代假设（Weak Generational Hypothesis）**：

> **绝大多数对象在创建后很快就会死亡。**

基于这个假设，我们将内存中的对象划分为两个“阶级”：

1. **新生代（Young Generation）**：
- 刚创建出来的对象。
- **特点**：死亡率极高，大部分也是垃圾。
- **策略**：**Minor GC（局部回收）**。GC 频繁地只扫描这一块区域，因为这里垃圾最多，回收性价比最高。
2. **老年代（Old Generation）**：
- 活过了 GC 扫荡的对象。
- **特点**：一旦活下来，往往能活很久（比如全局配置、UI 根节点）。
- **策略**：**Major GC（完整回收）**。GC 很少去打扰它们，除非内存真的不够用了。

这种策略避免了每次都去扫描那些“长期存活且并不活跃”的老年对象，从而极大降低了 CPU 开销。

## 分代GC的演化

其实早在 Lua 5.2 版本，官方就尝试过引入分代 GC，但后来在 5.3 中又删除了。为什么？因为它犯了一个策略上的错误：**“晋升得太快了”**。

### Lua 5.2 的“一轮游”策略

在 Lua 5.2 的设计中，对象只要活过**一次** Minor GC，就会立即被贴上“老年代”的标签。

- **场景**：你在函数里创建了一个对象 `obj`，紧接着发生了一次 Minor GC。
- **问题**：因为函数还没返回，`obj` 还在栈上，所以它被标记为“活着”。于是，它立刻变成了老年代。
- **后果**：函数随即返回，`obj` 本该死亡。但因为它已经是“老年代”了，Minor GC 不再扫描它。这个本该立即释放的垃圾，被迫一直占用内存，直到很久之后触发 Major GC 才能被回收。

这种**“假老年代”**（中间状态对象）越多，内存浪费就越严重，导致分代 GC 的优势荡然无存。

### Lua 5.4 的改进：“两轮变老”机制

吸取了教训后，Lua 5.4 引入了更严格的晋升机制。新创建的对象必须**经历两轮收集周期而依旧健在**，才有资格成为老年代。

1. **G_NEW (新对象)**：刚创建，属于新生代。
2. **G_SURVIVAL (幸存者)**：经历了一次 Minor GC，但还没“转正”。它依然被视为新生代的一部分，会被下一次 Minor GC 继续扫描。
3. **G_OLD (老年代)**：经历了第二次 Minor GC 依然存活，终于晋升。

**意义**：这增加了一个“缓冲期”。那些刚好跨越了 GC 边界的短命对象，会在“幸存者”阶段被第二次 Minor GC 抓住并清理掉，不会污染老年代。

## 触发机制：何时 Minor？何时 Major？

分代 GC 的运行依然是由内存分配驱动的，但决策逻辑变得更复杂了。

### 触发位置

和增量 GC 一样，Lua 在每次分配内存（`malloc`）时，会检查当前的 **GC Debt（债务）**，决定是否需要执行一步 GC 操作。

### Minor GC（次级收集）

这是分代模式下的常态。

- **触发条件**：新分配的内存达到一定阈值。
- **工作内容**：**只扫描新生代（G_NEW + G_SURVIVAL）**。
- **写屏障的作用**：如果老年代对象引用了新生代对象（比如 `OldTable.x = NewObj`），写屏障会将这个老年代对象标记为“脏（Touched）”。在 Minor GC 时，GC 也会扫描这些老年代，确保它们引用的新对象不会被误删。

### Major GC（主收集）

这是分代模式下的“兜底”操作，本质上是一次 Stop-the-World 的全量标记清除。

- **触发条件**： Lua 维护了一个“债务”指标。如果 Minor GC 清理得不够干净（即**晋升到老年代的对象太多**），债务就会累积。 当债务超过设定阈值（由 `majormul` 控制），说明Minor GC 已经搞不定了，必须触发 Major GC。
- **工作内容**：扫描整个虚拟机（_G、Registry、所有对象），重置所有对象的年龄。

## 避免停顿：一种混合策略

虽然分代 GC 平时很快，但 Major GC 依然会带来一次不可忽视的停顿（Stop-the-World）。在对延迟极度敏感的场景（如战斗逻辑、高频服务端）中，这可能是个隐患。

我们可以利用 Lua 提供的控制权，采用一种**“手动混合模式”**来消除停顿：

**策略逻辑**：

1. 平时开启 **分代模式**，享受 Minor GC 处理临时对象的高效。
2. 监控内存增长或 `GC count`。
3. 当发现内存持续增长，预感快要触发 Major GC 时，**不要等待它自动触发**。
4. **主动切换**到 **增量模式 (Incremental)**。
5. 在每一帧的空闲时间，手动调用 `collectgarbage("step")`，分摊 CPU 时间，慢慢跑完一次全量 GC。
6. 全量 GC 结束后，再切回 **分代模式**。
