<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>白山羊</title><link>https://WeissGoat.github.io/WBlog/</link><description>Recent content on 白山羊</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 08 Feb 2026 18:32:29 +0800</lastBuildDate><atom:link href="https://WeissGoat.github.io/WBlog/index.xml" rel="self" type="application/rss+xml"/><item><title>Lua 分代 GC</title><link>https://WeissGoat.github.io/WBlog/p/lua-%E5%88%86%E4%BB%A3-gc/</link><pubDate>Sun, 08 Feb 2026 18:32:29 +0800</pubDate><guid>https://WeissGoat.github.io/WBlog/p/lua-%E5%88%86%E4%BB%A3-gc/</guid><description>&lt;p&gt;Lua 5.4 引入的&lt;strong&gt;分代垃圾回收（Generational GC）&lt;/strong&gt;,相比于 Lua 5.3 的增量式 GC 专注于“降低停顿时间（Latency）”，Lua 5.4 的分代 GC 旨在解决“高吞吐量（Throughput）”场景下的性能瓶颈。特别是对于那些每一帧都产生大量临时对象（Short-lived objects）的游戏或高并发服务，分代 GC 能带来巨大的性能提升。&lt;/p&gt;
&lt;h2 id="分代假设"&gt;分代假设
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;分代假设（Generational Hypothesis）&lt;/strong&gt; 认为：&lt;strong&gt;“绝大多数对象在创建后很快就会死亡。”&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 Lua 5.3 的增量 GC 中，哪怕我们把 GC 拆分成了很多小步，但为了完成一轮完整的 GC 周期，收集器最终还是需要遍历整个堆（或者至少是大部分活跃对象）。如果堆中有几百万个长期存活的对象（比如加载的配置表、全局注册表），每次 GC 都要去确认它们“还在不在”，这本身就是一种巨大的算力浪费。&lt;/p&gt;
&lt;p&gt;Lua 5.4 的分代模式试图达成以下目标：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;忽略老年代&lt;/strong&gt;：默认老年代对象是“不死”的，除非有证据表明它们引用了新对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;聚焦年轻代&lt;/strong&gt;：集中火力快速扫描和清理新创建的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;零拷贝（Non-Moving）&lt;/strong&gt;：作为嵌入式语言，Lua 需要保持 C API 的指针稳定性，因此不能像 Java 或 Go 那样通过物理移动内存来整理堆。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种设计使得 Lua 5.4 在处理短命对象（如临时字符串、闭包、表）密集的场景下，性能比 5.3 提升显著，同时保持了极低的延迟。&lt;/p&gt;
&lt;h2 id="对象状态的深度解析"&gt;对象状态的深度解析
&lt;/h2&gt;&lt;p&gt;在分代模式下，Lua 利用 &lt;code&gt;GCObject&lt;/code&gt; 头部的标记位（Mark bits）构建了一个精细的状态机。为了更平滑地管理晋升，Lua 5.4 实际上将老年代细分为了两个阶段。&lt;/p&gt;
&lt;h3 id="状态全景图"&gt;状态全景图
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;G_NEW (Young)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;: 所有新创建的对象默认都是这个状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;命运&lt;/strong&gt;: 在 Minor GC 中，要么死掉，要么变成 Survivor。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;G_SURVIVAL&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;: 经历了一次 Minor GC 仍然存活，但还没“老”够两轮的对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;作用&lt;/strong&gt;: 这是一个缓冲带。很多对象可能刚好活过了一次 GC（例如跨帧存在的临时对象），如果直接晋升为老年代，下次 GC 就得扫描老年代或者等待 Major GC 才能回收它，成本太高。给它第二次机会，能有效减少“假冒老年代”的数量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;G_OLD0 (The &amp;ldquo;Really&amp;rdquo; Old)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;: 真正的老年代。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;特征&lt;/strong&gt;: 颜色为黑色（Black）。GC 在 Minor Collection 期间&lt;strong&gt;完全无视&lt;/strong&gt;它们。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;G_OLD1 (Old but visited)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;定义&lt;/strong&gt;: 这也是老年代，但在当前的 GC 周期中，它们是“刚晋升”上来的，或者有着特殊的标记意义。在源码中，&lt;code&gt;G_OLD0&lt;/code&gt; 和 &lt;code&gt;G_OLD1&lt;/code&gt; 经常通过位运算切换，用于区分不同周期的老年代，防止在同一个周期内重复处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;G_TOUCHED (The Remembered Set)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;定义&lt;/strong&gt;: 一个被“弄脏”的老年代对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;触发&lt;/strong&gt;: 当 &lt;code&gt;old_obj[key] = new_obj&lt;/code&gt; 发生时，&lt;code&gt;old_obj&lt;/code&gt; 会从 &lt;code&gt;G_OLD&lt;/code&gt; 变为 &lt;code&gt;G_TOUCHED&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;存储&lt;/strong&gt;: 它们会被链入 &lt;code&gt;grayagain&lt;/code&gt; 列表。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="状态流转图"&gt;状态流转图
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;[ G_NEW ] --(Minor GC 存活)--&amp;gt; [ G_SURVIVAL ] --(下一次 Minor GC 存活)--&amp;gt; [ G_OLD1 ] --&amp;gt; [ G_OLD0 ]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ^ |
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; | |
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; +----(被引用)----&amp;lt; [ G_TOUCHED ] &amp;lt;----(写屏障触发)-------------------------+
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="关键机制向前写屏障-forward-write-barrier"&gt;关键机制：向前写屏障 (Forward Write Barrier)
&lt;/h2&gt;&lt;p&gt;分代 GC 的核心难题是：&lt;strong&gt;如何知道哪些老年代对象引用了年轻代对象？&lt;/strong&gt; 如果不解决这个问题，回收年轻代时就必须扫描所有老年代对象，这会极其缓慢。&lt;/p&gt;
&lt;p&gt;Lua 使用 &lt;strong&gt;向前写屏障（Forward Write Barrier）&lt;/strong&gt; 来解决。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当执行 t[k] = v 时，如果 t 是老年代（Black），而 v 是新对象（White/Young）。&lt;/li&gt;
&lt;li&gt;触发屏障：luaC_barrier_。&lt;/li&gt;
&lt;li&gt;状态变更： t 被标记为 G_TOUCHED。&lt;/li&gt;
&lt;li&gt;加入列表： t 被放入 grayagain 列表（在这个上下文中，它被用作待扫描的根集合的一部分）。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="屏障触发逻辑"&gt;屏障触发逻辑
&lt;/h3&gt;&lt;p&gt;当执行 &lt;code&gt;lua_settable&lt;/code&gt; 或类似操作（&lt;code&gt;t[k] = v&lt;/code&gt;）时，虚拟机会调用 &lt;code&gt;luaC_barrier_&lt;/code&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 伪代码解析 lgc.c 中的 luaC_barrier_
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;luaC_barrier_&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lua_State&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GCObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;GCObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// o 是父对象 (table), v 是子对象 (value)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 只有当父对象是老年代 (isold)，且子对象是新对象 (iswhite) 时才触发
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;isold&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="nf"&gt;iswhite&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;v&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 标记 1: 将父对象标记为 TOUCHED
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 这意味着它不再是纯粹的 OLD，它持有对 Young 的引用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;setage&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;G_TOUCHED&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 标记 2: 将其放入 grayagain 列表
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// grayagain 本质上就是 &amp;#34;Remembered Set&amp;#34; (记忆集)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;linkgclist&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;grayagain&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="为什么叫向前"&gt;为什么叫“向前”？
&lt;/h3&gt;&lt;p&gt;Lua 使用 &lt;strong&gt;向前写屏障（Forward Write Barrier）&lt;/strong&gt; 来解决。这与增量 GC 中使用的“向后写屏障（Backwards Barrier，将父节点颜色改回灰色）”不同。&lt;/p&gt;
&lt;p&gt;在增量 GC 中，如果我们把黑色对象改回灰色（向后），GC 就需要重新扫描它。但在分代 GC 中，我们不希望重新扫描整个对象（如果它很大）。
Lua 的处理方式其实更接近于“把这个老年代对象暂时看作根节点”。在 Minor GC 开始时，它是扫描的起点之一。&lt;/p&gt;
&lt;h2 id="次级回收-minor-collection-的详细流程"&gt;次级回收 (Minor Collection) 的详细流程
&lt;/h2&gt;&lt;p&gt;次级回收（Minor Collection）的目标是：&lt;strong&gt;只清理年轻代对象&lt;/strong&gt;，且&lt;strong&gt;必须是原子操作&lt;/strong&gt;（不可中断，但由于只扫描年轻代和被触碰的老年代，速度极快）。&lt;/p&gt;
&lt;h3 id="触发时机"&gt;触发时机
&lt;/h3&gt;&lt;p&gt;由 &lt;code&gt;genminormul&lt;/code&gt; 参数控制。默认情况下，当新分配的内存达到上次存活内存的 20% 时触发。&lt;/p&gt;
&lt;h3 id="步骤详解"&gt;步骤详解
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;准备与根扫描 (Mark Roots)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GC 扫描主线程栈、全局注册表 (Registry) 等根节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意：这里只标记根节点&lt;strong&gt;直接指向&lt;/strong&gt;的年轻代对象。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;处理记忆集 (Scan GrayAgain / Touched)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这是分代 GC 能够成立的基石。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GC 遍历 &lt;code&gt;grayagain&lt;/code&gt; 列表。这里面全是 &lt;code&gt;G_TOUCHED&lt;/code&gt; 的老对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;关键逻辑&lt;/strong&gt;: 如果一个老对象在 &lt;code&gt;grayagain&lt;/code&gt; 里，GC 会扫描它引用的所有子对象。如果子对象是 &lt;code&gt;G_NEW&lt;/code&gt;，则将其标记为活跃。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态恢复&lt;/strong&gt;: 扫描完后，这个老对象通常会被改回 &lt;code&gt;G_OLD&lt;/code&gt; 状态。如果它之后又被修改，写屏障会再次捕获它。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;递归追踪 (Trace)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从上述步骤产生的灰色对象开始遍历。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;截断机制 (The Cut-off)&lt;/strong&gt;: 遍历过程中，一旦遇到 &lt;code&gt;isold(obj)&lt;/code&gt; 为真的对象，立刻停止深入。因为老年代对象被默认认为是“这就到头了，不用管它的子节点（除非它在 grayagain 里）”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这保证了遍历仅限制在年轻代对象图中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;清扫与晋升 (Sweep and Promote)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;此时，所有未被标记的年轻代对象都是垃圾。Lua 遍历全局对象链表（这在 Lua 5.4 中通过优化，不再遍历整个 allgc，而是利用指针操作高效处理）：
&lt;ul&gt;
&lt;li&gt;死亡对象（Dead Young）： 既不是老年代，也没被标记为活跃。 -&amp;gt; 释放内存。&lt;/li&gt;
&lt;li&gt;幸存对象（Survivor）： 它是年轻代，但被标记为活跃。
&lt;ul&gt;
&lt;li&gt;如果它之前是 G_NEW，将其改为 G_SURVIVAL（给它第二次机会证明自己是垃圾）。&lt;/li&gt;
&lt;li&gt;如果它之前是 G_SURVIVAL，将其晋升为 G_OLD（晋升）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;老年代对象（Old）： 忽略，不处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="逆序链表与哨兵"&gt;逆序链表与哨兵
&lt;/h2&gt;&lt;p&gt;这是 Lua GC 实现中最优雅的部分。Lua 不需要移动内存块来整理堆，它通过巧妙的链表操作实现了逻辑上的“分代移动”。&lt;/p&gt;
&lt;h3 id="数据结构时间逆序链表"&gt;数据结构：时间逆序链表
&lt;/h3&gt;&lt;p&gt;Lua 的全局对象链表 &lt;code&gt;allgc&lt;/code&gt; 是&lt;strong&gt;按时间逆序排列&lt;/strong&gt;的。因为新对象总是插入到链表头部。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;span class="lnt"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-text" data-lang="text"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;内存地址: High &amp;lt;--------------------------------------&amp;gt; Low
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;逻辑链表: HEAD (g-&amp;gt;allgc)
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; |
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; v
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; [ 新对象 A ] -&amp;gt; [ 新对象 B ] -&amp;gt; [ 幸存者 S ] -&amp;gt; [ 老对象 O1 ] -&amp;gt; [ 老对象 O2 ] -&amp;gt; NULL
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; (G_NEW) (G_NEW) (G_SURVIVAL) (G_OLD) (G_OLD)
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ^
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; |
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; g-&amp;gt;survival (哨兵指针)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;g-&amp;gt;survival&lt;/code&gt; 指针指向了&lt;strong&gt;上一次 GC 时的边界&lt;/strong&gt;。换句话说，&lt;code&gt;g-&amp;gt;survival&lt;/code&gt; 之后的所有对象，在本次 Minor GC 开始前就已经存在了，它们要么是幸存者，要么是老年代，反正&lt;strong&gt;绝不是 G_NEW&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="截断式清扫-sweep"&gt;截断式清扫 (Sweep)
&lt;/h3&gt;&lt;p&gt;由于这种排列特性，Minor GC 的清扫阶段&lt;strong&gt;不需要遍历整个链表&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Sweep 逻辑演示 (伪代码):&lt;/strong&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;span class="lnt"&gt;27
&lt;/span&gt;&lt;span class="lnt"&gt;28
&lt;/span&gt;&lt;span class="lnt"&gt;29
&lt;/span&gt;&lt;span class="lnt"&gt;30
&lt;/span&gt;&lt;span class="lnt"&gt;31
&lt;/span&gt;&lt;span class="lnt"&gt;32
&lt;/span&gt;&lt;span class="lnt"&gt;33
&lt;/span&gt;&lt;span class="lnt"&gt;34
&lt;/span&gt;&lt;span class="lnt"&gt;35
&lt;/span&gt;&lt;span class="lnt"&gt;36
&lt;/span&gt;&lt;span class="lnt"&gt;37
&lt;/span&gt;&lt;span class="lnt"&gt;38
&lt;/span&gt;&lt;span class="lnt"&gt;39
&lt;/span&gt;&lt;span class="lnt"&gt;40
&lt;/span&gt;&lt;span class="lnt"&gt;41
&lt;/span&gt;&lt;span class="lnt"&gt;42
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;GCObject&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;allgc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;GCObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;GCObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;limit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;survival&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 我们的终点站
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 只要还没碰到老年代的边界，就一直循环
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;limit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nf"&gt;is_marked&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// === 存活对象处理 ===
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 晋升逻辑：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 如果是 G_NEW -&amp;gt; 变成 G_SURVIVAL
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 如果是 G_SURVIVAL -&amp;gt; 变成 G_OLD1 (正式晋升)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;promote_age&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 清除标记位，为下一次 GC 做准备 (变为白色)
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;make_white&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 指针步进：这个对象留下了，检查下一个
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// === 死亡对象处理 ===
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 这是一个垃圾对象！
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;GCObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;dead&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 链表摘除操作：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// *p 指向 curr-&amp;gt;next，直接跳过 current
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;curr&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 释放内存
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;freeobj&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dead&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 注意：这里 p 不动，因为 *p 已经指向了原本的 next，
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;// 下次循环会直接检查那个新对象。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 循环结束！
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 此时 *p 等于 limit。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 后面那几百万个老年代对象完全不需要访问，Cache 友好度满分。
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="链表剪接与状态更新"&gt;链表剪接与状态更新
&lt;/h3&gt;&lt;p&gt;在 Sweep 结束后，我们需要设定新的边界。&lt;/p&gt;
&lt;p&gt;假设在上面的例子中，&lt;code&gt;新对象 A&lt;/code&gt; 死了，&lt;code&gt;新对象 B&lt;/code&gt; 活了。
现在的链表变成了：
&lt;code&gt;[ B (Survival) ] -&amp;gt; [ S (Old) ] -&amp;gt; [ O1 (Old) ] ...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时，&lt;code&gt;g-&amp;gt;survival&lt;/code&gt; 指针需要更新，指向现在的表头 &lt;code&gt;g-&amp;gt;allgc&lt;/code&gt;。
&lt;strong&gt;这一步操作瞬间完成了“代”的切换。&lt;/strong&gt; 今天幸存下来的对象，在下一次 GC 时就会位于 &lt;code&gt;g-&amp;gt;survival&lt;/code&gt; 指针的后面，成为受保护的老年代。&lt;/p&gt;
&lt;h2 id="什么时候会崩回退到-major-gc"&gt;什么时候会“崩”？(回退到 Major GC)
&lt;/h2&gt;&lt;p&gt;分代 GC 虽好，但在某些模式下会失效，甚至比普通 GC 更慢。Lua 5.4 引入了回退机制。&lt;/p&gt;
&lt;h3 id="触发-major-gc-的条件"&gt;触发 Major GC 的条件
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;老年代膨胀 (Memory Growth)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;genmajormul&lt;/code&gt; 参数控制（默认 100%）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果老年代的内存大小比上一次 Major GC 时翻了一倍，说明老年代本身在快速增长，Minor GC 已经无法控制内存总量了，必须做一次全量清理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Bad Touch (G_TOUCHED 过多)&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这是最阴险的性能杀手。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;原理&lt;/strong&gt;: Minor GC 的成本 = 扫描年轻代 + &lt;strong&gt;扫描 Touched 老年代&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 &lt;code&gt;grayagain&lt;/code&gt; 列表非常长，G_TOUCHED 的对象太多了。这意味着老年代频繁指向新对象（例如把一个巨大的老表当成缓冲区不断写入新数据）,Minor GC 就不再是“Minor”了，它会退化成一次接近全量的扫描。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Lua 内部会计数 &lt;code&gt;grayagain&lt;/code&gt; 的大小，如果它超过了总内存的一定比例，就会强制转为 Major GC。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此时，Lua 会触发一次 Major Collection。这本质上是一次完整的标记-清除循环：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;扫描所有对象。&lt;/li&gt;
&lt;li&gt;清理所有死对象（无论老少）。&lt;/li&gt;
&lt;li&gt;重置所有存活对象为 G_OLD。&lt;/li&gt;
&lt;li&gt;清空 grayagain 列表。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="bad-touch-代码示例"&gt;&amp;ldquo;Bad Touch&amp;rdquo; 代码示例
&lt;/h3&gt;&lt;p&gt;这就是所谓的“把老年代当缓冲区用”。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-lua" data-lang="lua"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;-- 场景：config 是一个常驻内存的老年代 Table&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kd"&gt;local&lt;/span&gt; &lt;span class="n"&gt;config&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;-- 这是一个高频调用的函数，比如每帧调用&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;function&lt;/span&gt; &lt;span class="nf"&gt;onUpdate&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;-- 这是一个典型的 Bad Touch 模式&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;-- 我们不断地创建新表 {}，并把它赋值给老表 config 的字段&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;-- 触发写屏障：config 变黑 -&amp;gt; 变灰 (TOUCHED) -&amp;gt; 加入 grayagain&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;config.last_frame_data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;-- 这种写法会导致 config 表在每一次 Minor GC 中都被扫描！&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="c1"&gt;-- 如果 config 表很大（比如有几万个字段），GC 耗时会瞬间飙升。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="kr"&gt;end&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;优化建议&lt;/strong&gt;: 如果必须频繁更新，尽量复用年轻代对象，或者将变动的数据隔离在一个独立的年轻代 Table 中，不要让它频繁污染巨大的老年代根节点。&lt;/p&gt;
&lt;h2 id="实际应用中的问题"&gt;实际应用中的问题
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;分代回收的次级回收周期以及全量回收都是是 Stop-the-World&amp;quot;（全停顿） 的策略。&lt;/li&gt;
&lt;li&gt;“脏”老年代过多 (内存过高)时的性能问题&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在对延迟极度敏感的场景（如战斗逻辑、高频服务端）中，是不能接受了, 会导致大内存服务的卡顿问题&lt;/p&gt;
&lt;h2 id="优化策略"&gt;优化策略
&lt;/h2&gt;&lt;p&gt;在不同内存使用情况下采用最适合的垃圾回收方式，以优化性能&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在低内存时(比如500M)使用分代回收，享受他带来的性能提升&lt;/li&gt;
&lt;li&gt;当内存使用较高时，切换到增量模式，通过周期性地执行小步骤的垃圾回收，避免一次性长时间的GC暂停&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>Lua Table</title><link>https://WeissGoat.github.io/WBlog/p/lua-table/</link><pubDate>Mon, 05 Feb 2024 18:00:00 +0800</pubDate><guid>https://WeissGoat.github.io/WBlog/p/lua-table/</guid><description>&lt;h2 id="核心数据结构"&gt;核心数据结构
&lt;/h2&gt;&lt;p&gt;Lua Table 的高效由其底层的 &lt;code&gt;struct Table&lt;/code&gt; 决定。从源码中我们可以清晰地看到，它并非单纯的哈希表，而是&lt;strong&gt;数组&lt;/strong&gt;与&lt;strong&gt;哈希表&lt;/strong&gt;的结合体。&lt;/p&gt;
&lt;h3 id="table-结构体定义"&gt;Table 结构体定义
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;typedef struct Table {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; CommonHeader;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; lu_byte flags; /* 1&amp;lt;&amp;lt;p means tagmethod(p) is not present (元方法缓存) */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; lu_byte lsizenode; /* 哈希表长度的对数，即 hash_size = 2^lsizenode */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; unsigned int alimit;/* 数组部分的“逻辑”大小 (即 sizearray) */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; TValue *array; /* 数组部分指针 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; Node *node; /* 哈希桶数组起始指针 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; Node *lastfree; /* 指向哈希部分最后一个空闲位置，用于快速插入 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; struct Table *metatable; /* 元表 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; GCObject *gclist;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;} Table;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;设计解读：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;双重存储&lt;/strong&gt;：&lt;code&gt;array&lt;/code&gt; 指针管理连续内存，用于存放整数键（1..n）；&lt;code&gt;node&lt;/code&gt; 指针管理哈希桶，用于存放其他键或离散的整数键。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;空间换时间&lt;/strong&gt;：&lt;code&gt;lastfree&lt;/code&gt; 指针的设计非常巧妙，它避免了每次插入时线性扫描寻找空位，将查找空闲位置的复杂度尽量降低。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;lsizenode&lt;/strong&gt;：哈希表的大小始终保持为 2 的幂次，这里存储的是幂次（log2），省去了存储实际大小的内存，计算时位移即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="节点node与键key"&gt;节点（Node）与键（Key）
&lt;/h3&gt;&lt;p&gt;哈希部分的节点结构如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;typedef union TKey {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; struct {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; TValuefields;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; struct Node *next; /* 链表法解决冲突，指向下一个冲突节点 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; } nk;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; TValue tvk;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;} TKey;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;typedef struct Node {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; TValue i_val;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; TKey i_key;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;} Node;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这里 &lt;code&gt;Node&lt;/code&gt; 包含了 Key 和 Value。Key 是一个 union，为了内存对齐和访问效率，当发生哈希冲突时，通过 &lt;code&gt;next&lt;/code&gt; 指针形成单向链表。&lt;/p&gt;
&lt;h2 id="键的归属数组还是哈希"&gt;键的归属：数组还是哈希？
&lt;/h2&gt;&lt;p&gt;当我们执行 &lt;code&gt;t[k] = v&lt;/code&gt; 时，Lua 是如何决定把数据存在 &lt;code&gt;array&lt;/code&gt; 还是 &lt;code&gt;node&lt;/code&gt; 里的？&lt;/p&gt;
&lt;h3 id="整数键的vip-通道"&gt;整数键的“VIP 通道”
&lt;/h3&gt;&lt;p&gt;一般情况下，正整数键（如 &lt;code&gt;t[1]&lt;/code&gt;, &lt;code&gt;t[100]&lt;/code&gt;）会优先尝试放入数组部分。但并非所有整数都会进入数组，必须满足&lt;strong&gt;利用率原则&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;核心规则&lt;/strong&gt;：包含当前 key 的区间 $[1, 2^n]$ 内，非空元素数量必须大于 $2^{n-1}$（即利用率 &amp;gt; 50%）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;源码 (&lt;code&gt;ltable.c&lt;/code&gt;)&lt;/strong&gt;： Lua 通过 &lt;code&gt;computesizes&lt;/code&gt; 函数来计算数组的最佳大小，代码清晰地展示了“&amp;gt; 50%”的判断逻辑：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;/* 计算数组部分的最佳大小 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;static unsigned int computesizes (unsigned int nums[], unsigned int *narray) {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; int i;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; unsigned int twotoi; /* 2^i */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; unsigned int a = 0; /* 统计小于 2^i 的元素个数 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; unsigned int na = 0; /* 最终落入数组部分的元素个数 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; unsigned int optimal = 0; /* 最佳数组大小 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; /* 循环遍历每个 2^i 区间 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; for (i = 0, twotoi = 1; twotoi/2 &amp;lt; *narray; i++, twotoi *= 2) {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; if (nums[i] &amp;gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; a += nums[i];
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; if (a &amp;gt; twotoi/2) { /* 核心判断：利用率 &amp;gt; 50% */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; optimal = twotoi;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; na = a;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; *narray = optimal;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; return na;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;举个例子&lt;/strong&gt;： 如果你创建了一个表 &lt;code&gt;t = {[1]=1, [1000]=1}&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1&lt;/code&gt; 在数组部分。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1000&lt;/code&gt; 虽然是整数，但如果强行扩容数组到 1000，中间会有 998 个空洞，不满足 &lt;code&gt;a &amp;gt; twotoi/2&lt;/code&gt;。因此，&lt;code&gt;1000&lt;/code&gt; 会被当作普通 Key 扔进哈希部分。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="哈希部分的收容所"&gt;哈希部分的“收容所”
&lt;/h3&gt;&lt;p&gt;以下情况 Key 会进入哈希表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;非整数类型&lt;/strong&gt;：字符串、Table、Userdata 等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;越界的整数&lt;/strong&gt;：数值极大，或者像上面提到的过于稀疏的整数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;负数&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="冲突解决brents-method-的变种"&gt;冲突解决：Brent&amp;rsquo;s Method 的变种
&lt;/h2&gt;&lt;p&gt;这是 Lua Table 实现中最“骚”的操作之一。&lt;/p&gt;
&lt;p&gt;通常哈希表解决冲突用的是&lt;strong&gt;开链法（Open Addressing with Chaining）&lt;/strong&gt;，但 Lua 为了节省内存，并没有在这个链表之外单独分配内存，而是直接利用哈希桶数组中未被使用的槽位。&lt;/p&gt;
&lt;h3 id="插入逻辑insert"&gt;插入逻辑（Insert）
&lt;/h3&gt;&lt;p&gt;当我们要插入一个新的 Key (&lt;code&gt;new_key&lt;/code&gt;)，算出它应该在的位置 &lt;code&gt;main_pos&lt;/code&gt;，却发现那里已经有“人”了 (&lt;code&gt;old_node&lt;/code&gt;)，Lua 会根据 &lt;code&gt;old_node&lt;/code&gt; 的身份采取不同策略。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;源码 (&lt;code&gt;luaH_newkey&lt;/code&gt;)&lt;/strong&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;span class="lnt"&gt;25
&lt;/span&gt;&lt;span class="lnt"&gt;26
&lt;/span&gt;&lt;span class="lnt"&gt;27
&lt;/span&gt;&lt;span class="lnt"&gt;28
&lt;/span&gt;&lt;span class="lnt"&gt;29
&lt;/span&gt;&lt;span class="lnt"&gt;30
&lt;/span&gt;&lt;span class="lnt"&gt;31
&lt;/span&gt;&lt;span class="lnt"&gt;32
&lt;/span&gt;&lt;span class="lnt"&gt;33
&lt;/span&gt;&lt;span class="lnt"&gt;34
&lt;/span&gt;&lt;span class="lnt"&gt;35
&lt;/span&gt;&lt;span class="lnt"&gt;36
&lt;/span&gt;&lt;span class="lnt"&gt;37
&lt;/span&gt;&lt;span class="lnt"&gt;38
&lt;/span&gt;&lt;span class="lnt"&gt;39
&lt;/span&gt;&lt;span class="lnt"&gt;40
&lt;/span&gt;&lt;span class="lnt"&gt;41
&lt;/span&gt;&lt;span class="lnt"&gt;42
&lt;/span&gt;&lt;span class="lnt"&gt;43
&lt;/span&gt;&lt;span class="lnt"&gt;44
&lt;/span&gt;&lt;span class="lnt"&gt;45
&lt;/span&gt;&lt;span class="lnt"&gt;46
&lt;/span&gt;&lt;span class="lnt"&gt;47
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-gdscript3" data-lang="gdscript3"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;插入新键的核心逻辑&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;简化版&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;TValue&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;luaH_newkey&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lua_State&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Table&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;TValue&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="ne"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttisnil&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="n"&gt;luaG_runerror&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;#34;table index is nil&amp;#34;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="err"&gt;计算主位置&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Main&lt;/span&gt; &lt;span class="n"&gt;Position&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;mp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mainposition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="err"&gt;如果主位置已被占用&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;ttisnil&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;mp&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;dummynode&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="ne"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;othern&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;获取空闲位置&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;lastfree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="ne"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getfreepos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;没位置了？扩容&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;rehash&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;luaH_set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;计算占位者&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;old_node&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="err"&gt;原本该在的主位置&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;othern&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mainposition&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;keyfromval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;othern&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;Case&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;鸠占鹊巢&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;把&lt;/span&gt; &lt;span class="n"&gt;old_node&lt;/span&gt; &lt;span class="err"&gt;赶到&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;othern&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;gnext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;othern&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;othern&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;gnext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;othern&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;找到指向&lt;/span&gt; &lt;span class="n"&gt;mp&lt;/span&gt; &lt;span class="err"&gt;的前驱&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;gnext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;othern&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cast_int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;othern&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;修正链表指向新位置&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;搬迁数据&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;腾出&lt;/span&gt; &lt;span class="n"&gt;mp&lt;/span&gt; &lt;span class="err"&gt;给新键，因为&lt;/span&gt; &lt;span class="n"&gt;mp&lt;/span&gt; &lt;span class="err"&gt;是新键的主位置&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;gnext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;setnilvalue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="n"&gt;Case&lt;/span&gt; &lt;span class="n"&gt;B&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;原住民冲突&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="err"&gt;新键只能去&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="n"&gt;pos&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gnext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;gnext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cast_int&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;gnext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;头插法：链在&lt;/span&gt; &lt;span class="n"&gt;mp&lt;/span&gt; &lt;span class="err"&gt;后面&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;gnext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;gnext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cast_int&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;mp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;setnodekey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;i_key&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;gval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;情况 A：鸠占鹊巢&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;old_node&lt;/code&gt; 是被挤到这里的（即 &lt;code&gt;othern != mp&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作&lt;/strong&gt;：Lua 把它挪到 &lt;code&gt;lastfree&lt;/code&gt;，把 &lt;code&gt;main_pos&lt;/code&gt; 抢回来给 &lt;code&gt;new_key&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：保证 &lt;code&gt;new_key&lt;/code&gt; 这种“原住民”能直接找到位置，减少后续查找的开销。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;情况 B：原住民冲突&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;old_node&lt;/code&gt; 本来就该待在这里。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作&lt;/strong&gt;：&lt;code&gt;new_key&lt;/code&gt; 去 &lt;code&gt;lastfree&lt;/code&gt;，并链接在 &lt;code&gt;old_node&lt;/code&gt; 后面。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种机制被称为 &lt;strong&gt;Chained Scatter Table&lt;/strong&gt;，它充分利用了数组空间，避免了由于大量微小对象分配导致的内存碎片。&lt;/p&gt;
&lt;h2 id="动态扩容rehash-的艺术"&gt;动态扩容：Rehash 的艺术
&lt;/h2&gt;&lt;p&gt;Table 的空间不是固定的。当空间不足或利用率失衡时，会触发 Rehash。&lt;/p&gt;
&lt;h3 id="触发时机"&gt;触发时机
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;插入新键且空间已满&lt;/strong&gt;：当我们赋值一个新键，而 Table 既没有数组空间，也没有哈希空位时。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;注意&lt;/strong&gt;：将某个 Key 置为 &lt;code&gt;nil&lt;/code&gt; &lt;strong&gt;不会&lt;/strong&gt;立即触发 Rehash（为了防止频繁的内存抖动）。只有在空间不足需要重新评估时，才会回收 &lt;code&gt;nil&lt;/code&gt; 占用的空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="rehash-的三部曲"&gt;Rehash 的三部曲
&lt;/h3&gt;&lt;p&gt;Rehash 是一个相对昂贵的操作，Lua 必须一次性重新计算数组和哈希两部分的最佳大小。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;统计（Counting）&lt;/strong&gt;： 遍历整个 Table（包括现有的 Array 和 Hash 部分），统计所有正整数键的数量，并按 $2^n$ 的区间（1-2, 3-4, 5-8&amp;hellip;）进行分桶统计。同时统计非整数键的总数。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;定界（Sizing）&lt;/strong&gt;： 计算数组部分的最佳大小 &lt;code&gt;sizearray&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;算法：找到最大的 $N$（$2$ 的幂），使得 $[1, N]$ 区间内的整数键数量 $\ge N/2$。&lt;/li&gt;
&lt;li&gt;凡是小于等于 $N$ 的整数放入新数组，其余放入新哈希表。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="3"&gt;
&lt;li&gt;&lt;strong&gt;搬迁（Relocation）&lt;/strong&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;申请新的 Array 和 Hash 内存块。&lt;/li&gt;
&lt;li&gt;将数据搬运过去（重新计算哈希值）。&lt;/li&gt;
&lt;li&gt;释放旧内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这解释了为什么 Lua Table 既能像 C 数组一样紧凑高效，又能像 Python Dict 一样灵活。&lt;/p&gt;
&lt;h2 id="迭代器的秘密pairs-与-ipairs"&gt;迭代器的秘密：pairs 与 ipairs
&lt;/h2&gt;&lt;p&gt;我们在写 Lua 时常用的两种遍历方式，其底层性能差异巨大。&lt;/p&gt;
&lt;h3 id="ipairs序列专用"&gt;ipairs：序列专用
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ipairs&lt;/code&gt; 是为**序列（Sequence）**量身定做的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;逻辑&lt;/strong&gt;：维护一个内部计数器 &lt;code&gt;i&lt;/code&gt;，从 1 开始递增。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;寻址&lt;/strong&gt;：Lua 内部会先判断 &lt;code&gt;i&lt;/code&gt; 是否在 &lt;code&gt;array&lt;/code&gt; 的范围内。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;源码 (&lt;code&gt;luaH_getint&lt;/code&gt;)&lt;/strong&gt;： 这是整数查找的入口函数，清晰展示了“先查数组，再查哈希”的逻辑：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-gdscript3" data-lang="gdscript3"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;TValue&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;luaH_getint&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Table&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lua_Integer&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="err"&gt;数组部分快速查找&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Fast&lt;/span&gt; &lt;span class="ne"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;这里的&lt;/span&gt; &lt;span class="n"&gt;alimit&lt;/span&gt; &lt;span class="err"&gt;就是数组的逻辑大小&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l_castS2U&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;alimit&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;array&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;key&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="err"&gt;哈希部分查找&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Slow&lt;/span&gt; &lt;span class="ne"&gt;Path&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="ne"&gt;Node&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;hashint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ttisinteger&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gkey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;ivalue&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gkey&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;key&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;gval&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;找到了&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="ne"&gt;int&lt;/span&gt; &lt;span class="n"&gt;nx&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gnext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nx&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;nx&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;/*&lt;/span&gt; &lt;span class="err"&gt;沿着冲突链查找&lt;/span&gt; &lt;span class="o"&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;luaO_nilobject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;在范围内&lt;/strong&gt;：直接通过指针偏移 &lt;code&gt;array[i]&lt;/code&gt; 读取，这几乎就是 C 语言访问数组的速度，&lt;strong&gt;极快&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不在范围内&lt;/strong&gt;：才去查 Hash 表。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="pairs全量遍历"&gt;pairs：全量遍历
&lt;/h3&gt;&lt;p&gt;&lt;code&gt;pairs&lt;/code&gt; 使用的是 &lt;code&gt;lua_next&lt;/code&gt; 函数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;流程&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;先遍历数组部分&lt;/strong&gt;：从下标 0 到 &lt;code&gt;sizearray&lt;/code&gt; 线性扫描。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;再遍历哈希部分&lt;/strong&gt;：从哈希桶的第一个位置扫描到最后一个位置。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;顺序问题&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;对于&lt;strong&gt;纯数组&lt;/strong&gt;表（如 &lt;code&gt;{10, 20, 30}&lt;/code&gt;），因为只扫描数组部分，输出看起来是有序的。&lt;/li&gt;
&lt;li&gt;一旦涉及哈希部分，顺序就是&lt;strong&gt;乱序&lt;/strong&gt;的。这是因为 Key 在哈希表中的物理位置取决于 Hash 算法和冲突时的插入顺序，与逻辑顺序无关。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;不要依赖 &lt;code&gt;pairs&lt;/code&gt; 的遍历顺序，除非你确认表是纯数组且尚未发生过复杂的 Rehash。&lt;/p&gt;
&lt;/blockquote&gt;</description></item><item><title>Lua 增量 GC</title><link>https://WeissGoat.github.io/WBlog/p/lua-%E5%A2%9E%E9%87%8F-gc/</link><pubDate>Mon, 05 Feb 2024 18:00:00 +0800</pubDate><guid>https://WeissGoat.github.io/WBlog/p/lua-%E5%A2%9E%E9%87%8F-gc/</guid><description>&lt;h1 id="lua-gc-三色标记增量回收与写屏障"&gt;Lua GC ：三色标记、增量回收与写屏障
&lt;/h1&gt;&lt;h2 id="从-stop-the-world-到增量"&gt;从 Stop-the-World 到增量
&lt;/h2&gt;&lt;h3 id="lua-50简单的代价"&gt;Lua 5.0：简单的代价
&lt;/h3&gt;&lt;p&gt;在 Lua 5.0 时代，GC 算法非常朴素：&lt;strong&gt;双倍阈值，全量回收&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;逻辑&lt;/strong&gt;：当内存使用量达到上次 GC 后的两倍时，虚拟机暂停所有业务逻辑，跑一遍完整的“标记-清除”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后果&lt;/strong&gt;：这就是著名的 &lt;strong&gt;Stop-the-World (STW)&lt;/strong&gt;。如果你的 Lua 内存占用了 1GB，GC 触发的那一瞬间，整个游戏或服务可能会卡顿几百毫秒甚至更久。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="lua-51三色增量标记tri-color-incremental-mark--sweep"&gt;Lua 5.1+：三色增量标记（Tri-color Incremental Mark &amp;amp; Sweep）
&lt;/h3&gt;&lt;p&gt;为了解决卡顿，Lua 5.1 引入了增量 GC。GC 过程与业务代码交替运行。&lt;/p&gt;
&lt;p&gt;为了实现“可中断、可恢复”的扫描，Lua 引入了&lt;strong&gt;三色标记法&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id="核心算法三色标记与双白设计"&gt;核心算法：三色标记与双白设计
&lt;/h2&gt;&lt;p&gt;GC 的本质是从根节点（_G、Registry、栈）出发，找到所有可达对象。在增量扫描过程中，对象被标记为三种颜色：&lt;/p&gt;
&lt;h3 id="颜色的含义"&gt;颜色的含义
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;⚪ 白色 (White)&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：当前还未被 GC 访问到的对象，或者已死亡的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始状态&lt;/strong&gt;：所有新创建的对象默认为白色。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结局&lt;/strong&gt;：如果 GC 结束后还是白色，说明不可达，&lt;strong&gt;回收&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;⚫ 黑色 (Black)&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：&lt;strong&gt;已扫描完毕&lt;/strong&gt;。该对象及其引用的所有子对象都已经被访问过了。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;特性&lt;/strong&gt;：GC 这一轮不会再回头看它。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;🔘 灰色 (Gray)&lt;/strong&gt;：&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：&lt;strong&gt;待处理&lt;/strong&gt;。该对象已被访问（从白色变成了灰色），但它引用的子对象还没扫描完。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;作用&lt;/strong&gt;：灰色是当前扫描的边缘（Frontier），保存在一个链表中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="巧妙的双白设计-the-two-whites"&gt;巧妙的“双白”设计 (The Two Whites)
&lt;/h3&gt;&lt;p&gt;我在研究源码时发现一个有趣的细节：Lua 的白色其实细分为 &lt;strong&gt;White1&lt;/strong&gt; 和 &lt;strong&gt;White2&lt;/strong&gt;。这是为了解决什么问题？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;： GC 标记阶段已经快结束了（大部分是黑色），此时业务代码突然创建了一个新对象。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新对象默认是&lt;strong&gt;白色&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;如果不加区分，在接下来的“清除阶段”，GC 会认为这个白色的新对象是“没被引用的垃圾”并把它回收掉——&lt;strong&gt;这会导致严重 Bug&lt;/strong&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;： Lua 使用一个全局的位掩码 &lt;code&gt;CurrentWhite&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;本轮 GC&lt;/strong&gt;：只回收标记为“旧白色”的对象。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;新创建对象&lt;/strong&gt;：标记为“新白色”（CurrentWhite）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结果&lt;/strong&gt;：新对象在本轮 GC 中被视为“安全”，留到下一轮再处理。在清除阶段结束后，Lua 会轮转 &lt;code&gt;CurrentWhite&lt;/code&gt; 的值。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="状态机的流转gc-的生命周期"&gt;状态机的流转：GC 的生命周期
&lt;/h2&gt;&lt;p&gt;Lua 的增量 GC 是通过一个状态机驱动的。每次调用 &lt;code&gt;luaC_step&lt;/code&gt;，GC 就会向前推进一步。以下是主要的阶段：&lt;/p&gt;
&lt;h3 id="-gcspause-暂停初始化"&gt;① GCSpause (暂停/初始化)
&lt;/h3&gt;&lt;p&gt;GC 的起点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将根节点（主线程、全局表 _G、Registry 等）标记为&lt;strong&gt;灰色&lt;/strong&gt;，并加入灰色链表。&lt;/li&gt;
&lt;li&gt;此时，通过根节点的一波操作，我们有了第一批待扫描的灰色对象。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-gcspropagate-传播---最耗时的阶段"&gt;② GCSpropagate (传播 - 最耗时的阶段)
&lt;/h3&gt;&lt;p&gt;这是“增量”体现最明显的地方。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作&lt;/strong&gt;：从灰色链表中弹出一个对象，将其标记为&lt;strong&gt;黑色&lt;/strong&gt;，然后遍历它引用的所有子对象：&lt;/li&gt;
&lt;li&gt;如果是白色，将其染成&lt;strong&gt;灰色&lt;/strong&gt;并加入链表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;控制&lt;/strong&gt;：这个过程不是一次性做完的，而是受 &lt;code&gt;gcstepmul&lt;/code&gt; 控制，每次只处理一部分就暂停，把 CPU 让给业务逻辑。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-gcsatomic-原子阶段---必须一次做完"&gt;③ GCSatomic (原子阶段 - 必须一次做完)
&lt;/h3&gt;&lt;p&gt;这是这一轮 GC 中唯一需要 Stop-the-World 的时刻，但通常很快。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;目的&lt;/strong&gt;：因为 Propagate 阶段是并发的，业务代码可能在此期间修改了引用（比如把一个白色对象赋值给了一个已经黑色的 Table）。如果不修正，那个白色对象会被误删。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作&lt;/strong&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;重新遍历“灰名单”（GrayAgain，由写屏障产生，详见下文）。&lt;/li&gt;
&lt;li&gt;扫描弱引用表（Weak Tables）。&lt;/li&gt;
&lt;li&gt;完成所有剩余的标记工作。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="-gcssweepstring-字符串清理"&gt;④ GCSsweepstring (字符串清理)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;特点&lt;/strong&gt;：Lua 的短字符串是单独管理的（通常存储在全局哈希表中）。因为字符串没有子引用，清理非常快，直接从哈希表中移除未标记的字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-gcssweep-普通对象清理"&gt;⑤ GCSsweep (普通对象清理)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;操作&lt;/strong&gt;：遍历所有 GCObject 链表。&lt;/li&gt;
&lt;li&gt;如果是&lt;strong&gt;黑色&lt;/strong&gt;：说明活着，重置为当前白色（为下一轮做准备）。&lt;/li&gt;
&lt;li&gt;如果是&lt;strong&gt;旧白色&lt;/strong&gt;：说明死了，&lt;strong&gt;free&lt;/strong&gt; 掉内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="-gcsfinalize-终结"&gt;⑥ GCSfinalize (终结)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;处理所有实现了 &lt;code&gt;__gc&lt;/code&gt; 元方法的 Userdata。这些对象不会立即释放，而是会被放入一个单独的列表，等待虚拟机调用它们的析构函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="并发下的黑指向白与写屏障"&gt;并发下的“黑指向白”与写屏障
&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;GCSpropagate&lt;/code&gt; 阶段，GC 和业务逻辑是交替运行的。这就带来了一个严重的&lt;strong&gt;数据竞争&lt;/strong&gt;问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;问题场景&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;GC 标记了 Table A 为&lt;strong&gt;黑色&lt;/strong&gt;（认为 A 已经扫描完了）。&lt;/li&gt;
&lt;li&gt;业务代码执行 &lt;code&gt;A.x = B&lt;/code&gt;，其中 B 是一个&lt;strong&gt;白色&lt;/strong&gt;对象。&lt;/li&gt;
&lt;li&gt;因为 A 已经是黑色，GC 不会再扫描它。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后果&lt;/strong&gt;：B 作为一个被引用的对象，却因为没被扫描到，保持白色。在清除阶段，B 会被当垃圾回收，导致 &lt;code&gt;A.x&lt;/code&gt; 变成了野指针！&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="解决方案写屏障-write-barrier"&gt;解决方案：写屏障 (Write Barrier)
&lt;/h3&gt;&lt;p&gt;为了维护**“黑色对象不能指向白色对象”**这一不变量（Invariant），Lua 在每次修改引用（table set/assignment）时，会触发写屏障。&lt;/p&gt;
&lt;p&gt;写屏障有两种主要形式：&lt;/p&gt;
&lt;h4 id="1-前进屏障-forward-barrier---把白色染灰"&gt;1. 前进屏障 (Forward Barrier) - &amp;ldquo;把白色染灰&amp;rdquo;
&lt;/h4&gt;&lt;p&gt;如果你把白色对象 B 赋给黑色对象 A，屏障会立即把 &lt;strong&gt;B 染成灰色&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;意义&lt;/strong&gt;：既然 A 引用了 B，那 B 肯定是有用的，赶紧把 B 拉进待扫描清单。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用&lt;/strong&gt;：通常用于将新对象赋值给老对象时。用于 Closure (Upvalues)、Userdata 等。因为这些对象通常不像 Table 那样频繁修改引用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id="2-后退屏障-backward-barrier---把黑色回退变灰"&gt;2. 后退屏障 (Backward Barrier) - &amp;ldquo;把黑色回退变灰&amp;rdquo;
&lt;/h4&gt;&lt;p&gt;如果你把白色对象 B 赋给黑色对象 A，屏障把 &lt;strong&gt;A 变回灰色&lt;/strong&gt;，扔进 &lt;code&gt;grayagain&lt;/code&gt; 列表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;意义&lt;/strong&gt;：A 你虽然扫过了，但你现在又有了新欢，GC 稍后得回头再查你一次。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;应用&lt;/strong&gt;：通常用于 &lt;code&gt;Table&lt;/code&gt; 等容器。这是因为 Table 容易频繁变动，如果用前进屏障（把子对象变灰），下次 Table 再变动时又要触发屏障；而把 Table 变灰后，它就留在 Gray 链表中，之后再往里面塞白色对象就不需要触发屏障了（因为父对象已经是灰的了）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="源码窥探"&gt;源码窥探
&lt;/h3&gt;&lt;p&gt;让我们看看 Lua 内部宏 &lt;code&gt;luaC_barrier&lt;/code&gt; 的简化逻辑：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;/* 伪代码逻辑：写屏障 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;#define luaC_barrier(L, p, v) { \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; /* p 是父对象(Table)，v 是子对象(Value) */ \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; if (isblack(p) &amp;amp;&amp;amp; iswhite(v)) { \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; /* 触发屏障：黑色指向了白色 */ \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; luaC_barrier_(L, obj2gco(p), obj2gco(v)); \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; } \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;void luaC_barrier_ (lua_State *L, GCObject *p, GCObject *v) {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; /* 保持黑白不变性 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; if (isdead(L, v)) return; // 已经死的不管
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; // 策略：通常是将 v (子对象) 标灰 (Forward Barrier)
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; // 或者将 p (父对象) 放入 grayagain 列表 (Backward Barrier)
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; reallymarkobject(L, v);
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;正是这个 &lt;code&gt;luaC_barrier&lt;/code&gt;，保证了增量 GC 的正确性。它就像一个监视器，拦截了所有的赋值操作。&lt;/p&gt;
&lt;h2 id="gc触发的时机"&gt;GC触发的时机
&lt;/h2&gt;&lt;p&gt;假设我们执行以下代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;local i = 1234
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这行代码会触发 GC 吗？答案是&lt;strong&gt;不会&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;根据 Lua 的内存模型（如上文 &lt;code&gt;TValue&lt;/code&gt; 结构所示）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;值类型（Value Types）&lt;/strong&gt;：如 &lt;code&gt;nil&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, &lt;code&gt;number&lt;/code&gt; (integer/float)。这些数据直接存放在 Lua 栈的 &lt;code&gt;TValue&lt;/code&gt; 结构体中。它们随着栈帧的销毁而自动消失，&lt;strong&gt;不涉及堆内存分配&lt;/strong&gt;（malloc），因此不计入 GC 的债务（GCdebt），自然也不会触发 GC 步进。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;引用类型（Reference Types）&lt;/strong&gt;：如 &lt;code&gt;table&lt;/code&gt;, &lt;code&gt;function&lt;/code&gt;, &lt;code&gt;string&lt;/code&gt; (长字符串), &lt;code&gt;userdata&lt;/code&gt;。这些对象存活在堆上，才是 GC 主要“追杀”的目标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 Lua 虚拟机源码中，几乎所有涉及内存分配的操作（如 &lt;code&gt;lua_newtable&lt;/code&gt;, &lt;code&gt;lua_pushstring&lt;/code&gt;）之后，都会调用一个检查宏：&lt;strong&gt;&lt;code&gt;luaC_checkGC&lt;/code&gt;&lt;/strong&gt;。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;#define luaC_checkGC(L) { \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; if (G(L)-&amp;gt;GCdebt &amp;gt; 0) { \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; luaC_step(L); \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; } \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; condchangemem(L,pre,pos); \
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;GCdebt&lt;/code&gt; (GC 债务)&lt;/strong&gt;：这是一个核心概念。每当你分配 1 字节内存，&lt;code&gt;GCdebt&lt;/code&gt; 就会增加 1。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;判断逻辑&lt;/strong&gt;：只要“债务”大于 0，Lua 就会认为“如果你制造了垃圾（或者申请了新内存），你就得负责清理一点垃圾”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;luaC_step&lt;/code&gt;&lt;/strong&gt;：这就是执行一次 GC“步进”的函数。它不会跑完整个 GC 流程，而是只跑一小步（具体跑多远，由 &lt;code&gt;stepmul&lt;/code&gt; 决定）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="控制-gc-的速率"&gt;控制 GC 的速率
&lt;/h2&gt;&lt;p&gt;了解了原理，我们就能看懂 &lt;code&gt;collectgarbage&lt;/code&gt; 的两个参数了：&lt;/p&gt;
&lt;h3 id="pause-暂停系数"&gt;&lt;code&gt;pause&lt;/code&gt; (暂停系数)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：GC的间歇率, 将 GCdebt 设置为一个巨大的负数来实现的, 默认值200（即 200%）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑&lt;/strong&gt;：如果当前内存是 10MB，GC 结束后回收到 5MB。那么下一次 GC 启动的阈值是 &lt;code&gt;5MB * 200% = 10MB&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;值越小，GC 越勤快，内存占用越低，但 CPU 消耗越高。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;static void setpause (global_State *g) {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; l_mem threshold, debt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; l_mem estimate = g-&amp;gt;GCestimate / 100; // 获取估算内存
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; l_mem pause = (g-&amp;gt;gcpause != 0) ? g-&amp;gt;gcpause : 200; // 默认 200
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; /* 计算我们要等待多少内存分配 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; threshold = (pause * estimate);
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; /* 设置债务 = 估算值 - 阈值
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 因为 阈值 通常 &amp;gt; 估算值，所以这里 debt 是负数
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; debt = gettotalbytes(g) - threshold;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; luaE_setdebt(g, debt);
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="stepmul-步进倍率"&gt;&lt;code&gt;stepmul&lt;/code&gt; (步进倍率)
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;含义&lt;/strong&gt;：控制 GC 扫描的速度。默认值 200(200%)。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;逻辑&lt;/strong&gt;：分配了 1 字节内存（增加了 1 字节债务）,GC 需要执行等同于 2 字节内存的工作量，才能把这 1 字节的债务“抵消”掉。&lt;/li&gt;
&lt;li&gt;如果你发现内存飙升得比 GC 回收得快（Alloc &amp;gt; Free），说明 GC 跑慢了，需要&lt;strong&gt;调大&lt;/strong&gt; &lt;code&gt;stepmul&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;如果你发现游戏明显卡顿，可能是 GC 一次步进占用 CPU 太多，尝试&lt;strong&gt;调小&lt;/strong&gt; &lt;code&gt;stepmul&lt;/code&gt; 让切片更细。&lt;/li&gt;
&lt;/ul&gt;</description></item><item><title>hello world</title><link>https://WeissGoat.github.io/WBlog/p/hello-world/</link><pubDate>Mon, 29 Jan 2024 00:00:00 +0000</pubDate><guid>https://WeissGoat.github.io/WBlog/p/hello-world/</guid><description>&lt;p&gt;很幸运生活在一个技术爆炸的时代, 感觉未来充满着可能性&lt;/p&gt;
&lt;p&gt;在这里展示我的生活, 我的思考, 我的成长&lt;/p&gt;</description></item><item><title>关于</title><link>https://WeissGoat.github.io/WBlog/%E5%85%B3%E4%BA%8E/</link><pubDate>Tue, 26 Jan 2021 00:00:00 +0000</pubDate><guid>https://WeissGoat.github.io/WBlog/%E5%85%B3%E4%BA%8E/</guid><description>&lt;p&gt;很幸运生活在一个技术爆炸的时代, 感觉未来充满着可能性&lt;/p&gt;
&lt;p&gt;在这里展示我的生活, 我的思考, 我的成长&lt;/p&gt;</description></item><item><title>归档</title><link>https://WeissGoat.github.io/WBlog/archives/</link><pubDate>Tue, 28 May 2019 00:00:00 +0000</pubDate><guid>https://WeissGoat.github.io/WBlog/archives/</guid><description/></item><item><title>搜索</title><link>https://WeissGoat.github.io/WBlog/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://WeissGoat.github.io/WBlog/search/</guid><description/></item></channel></rss>