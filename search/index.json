[{"content":"Lua GC ：三色标记、增量回收与写屏障 在上一篇文章中，我们探讨了 Lua 的数据结构（TValue）以及哪些对象是值类型，哪些是引用类型。今天，我们继续向下挖掘，聊聊 Lua 虚拟机中的垃圾回收机制（Garbage Collection）。\n从 Stop-the-World 到增量 Lua 5.0：简单的代价 在 Lua 5.0 时代，GC 算法非常朴素：双倍阈值，全量回收。\n逻辑：当内存使用量达到上次 GC 后的两倍时，虚拟机暂停所有业务逻辑，跑一遍完整的“标记-清除”。 后果：这就是著名的 Stop-the-World (STW)。如果你的 Lua 内存占用了 1GB，GC 触发的那一瞬间，整个游戏或服务可能会卡顿几百毫秒甚至更久。 Lua 5.1+：三色增量标记（Tri-color Incremental Mark \u0026amp; Sweep） 为了解决卡顿，Lua 5.1 引入了增量 GC。GC 过程与业务代码交替运行。\n为了实现“可中断、可恢复”的扫描，Lua 引入了三色标记法。\n核心算法：三色标记与双白设计 GC 的本质是从根节点（_G、Registry、栈）出发，找到所有可达对象。在增量扫描过程中，对象被标记为三种颜色：\n颜色的含义 ⚪ 白色 (White)： 含义：当前还未被 GC 访问到的对象，或者已死亡的对象。 初始状态：所有新创建的对象默认为白色。 结局：如果 GC 结束后还是白色，说明不可达，回收。 ⚫ 黑色 (Black)： 含义：已扫描完毕。该对象及其引用的所有子对象都已经被访问过了。 特性：GC 这一轮不会再回头看它。 🔘 灰色 (Gray)： 含义：待处理。该对象已被访问（从白色变成了灰色），但它引用的子对象还没扫描完。 作用：灰色是当前扫描的边缘（Frontier），保存在一个链表中。 巧妙的“双白”设计 (The Two Whites) 我在研究源码时发现一个有趣的细节：Lua 的白色其实细分为 White1 和 White2。这是为了解决什么问题？\n场景： GC 标记阶段已经快结束了（大部分是黑色），此时业务代码突然创建了一个新对象。\n新对象默认是白色。 如果不加区分，在接下来的“清除阶段”，GC 会认为这个白色的新对象是“没被引用的垃圾”并把它回收掉——这会导致严重 Bug。 解决方案： Lua 使用一个全局的位掩码 CurrentWhite。\n本轮 GC：只回收标记为“旧白色”的对象。 新创建对象：标记为“新白色”（CurrentWhite）。 结果：新对象在本轮 GC 中被视为“安全”，留到下一轮再处理。在清除阶段结束后，Lua 会轮转 CurrentWhite 的值。 状态机的流转：GC 的生命周期 Lua 的增量 GC 是通过一个状态机驱动的。每次调用 luaC_step，GC 就会向前推进一步。以下是主要的阶段：\n① GCSpause (暂停/初始化) GC 的起点。\n将根节点（主线程、全局表 _G、Registry 等）标记为灰色，并加入灰色链表。 此时，通过根节点的一波操作，我们有了第一批待扫描的灰色对象。 ② GCSpropagate (传播 - 最耗时的阶段) 这是“增量”体现最明显的地方。\n操作：从灰色链表中弹出一个对象，将其标记为黑色，然后遍历它引用的所有子对象： 如果是白色，将其染成灰色并加入链表。 控制：这个过程不是一次性做完的，而是受 gcstepmul 控制，每次只处理一部分就暂停，把 CPU 让给业务逻辑。 ③ GCSatomic (原子阶段 - 必须一次做完) 这是这一轮 GC 中唯一需要 Stop-the-World 的时刻，但通常很快。\n目的：因为 Propagate 阶段是并发的，业务代码可能在此期间修改了引用（比如把一个白色对象赋值给了一个已经黑色的 Table）。如果不修正，那个白色对象会被误删。 操作： 重新遍历“灰名单”（GrayAgain，由写屏障产生，详见下文）。 扫描弱引用表（Weak Tables）。 完成所有剩余的标记工作。 ④ GCSsweepstring (字符串清理) 特点：Lua 的短字符串是单独管理的（通常存储在全局哈希表中）。因为字符串没有子引用，清理非常快，直接从哈希表中移除未标记的字符串。 ⑤ GCSsweep (普通对象清理) 操作：遍历所有 GCObject 链表。 如果是黑色：说明活着，重置为当前白色（为下一轮做准备）。 如果是旧白色：说明死了，free 掉内存。 ⑥ GCSfinalize (终结) 处理所有实现了 __gc 元方法的 Userdata。这些对象不会立即释放，而是会被放入一个单独的列表，等待虚拟机调用它们的析构函数。 并发下的“黑指向白”与写屏障 在 GCSpropagate 阶段，GC 和业务逻辑是交替运行的。这就带来了一个严重的数据竞争问题。\n问题场景：\nGC 标记了 Table A 为黑色（认为 A 已经扫描完了）。 业务代码执行 A.x = B，其中 B 是一个白色对象。 因为 A 已经是黑色，GC 不会再扫描它。 后果：B 作为一个被引用的对象，却因为没被扫描到，保持白色。在清除阶段，B 会被当垃圾回收，导致 A.x 变成了野指针！ 解决方案：写屏障 (Write Barrier) 为了维护**“黑色对象不能指向白色对象”**这一不变量（Invariant），Lua 在每次修改引用（table set/assignment）时，会触发写屏障。\n写屏障有两种主要形式：\n1. 前进屏障 (Forward Barrier) - \u0026ldquo;把白色染灰\u0026rdquo; 如果你把白色对象 B 赋给黑色对象 A，屏障会立即把 B 染成灰色。\n意义：既然 A 引用了 B，那 B 肯定是有用的，赶紧把 B 拉进待扫描清单。 应用：通常用于将新对象赋值给老对象时。用于 Closure (Upvalues)、Userdata 等。因为这些对象通常不像 Table 那样频繁修改引用。 2. 后退屏障 (Backward Barrier) - \u0026ldquo;把黑色回退变灰\u0026rdquo; 如果你把白色对象 B 赋给黑色对象 A，屏障把 A 变回灰色，扔进 grayagain 列表。\n意义：A 你虽然扫过了，但你现在又有了新欢，GC 稍后得回头再查你一次。 应用：通常用于 Table 等容器。这是因为 Table 容易频繁变动，如果用前进屏障（把子对象变灰），下次 Table 再变动时又要触发屏障；而把 Table 变灰后，它就留在 Gray 链表中，之后再往里面塞白色对象就不需要触发屏障了（因为父对象已经是灰的了）。 源码窥探 让我们看看 Lua 内部宏 luaC_barrier 的简化逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 伪代码逻辑：写屏障 */ #define luaC_barrier(L, p, v) { \\ /* p 是父对象(Table)，v 是子对象(Value) */ \\ if (isblack(p) \u0026amp;\u0026amp; iswhite(v)) { \\ /* 触发屏障：黑色指向了白色 */ \\ luaC_barrier_(L, obj2gco(p), obj2gco(v)); \\ } \\ } void luaC_barrier_ (lua_State *L, GCObject *p, GCObject *v) { /* 保持黑白不变性 */ if (isdead(L, v)) return; // 已经死的不管 // 策略：通常是将 v (子对象) 标灰 (Forward Barrier) // 或者将 p (父对象) 放入 grayagain 列表 (Backward Barrier) reallymarkobject(L, v); } 正是这个 luaC_barrier，保证了增量 GC 的正确性。它就像一个监视器，拦截了所有的赋值操作。\nGC触发的时机 假设我们执行以下代码：\n1 local i = 1234 这行代码会触发 GC 吗？答案是不会。\n根据 Lua 的内存模型（如上文 TValue 结构所示）：\n值类型（Value Types）：如 nil, boolean, number (integer/float)。这些数据直接存放在 Lua 栈的 TValue 结构体中。它们随着栈帧的销毁而自动消失，不涉及堆内存分配（malloc），因此不计入 GC 的债务（GCdebt），自然也不会触发 GC 步进。 引用类型（Reference Types）：如 table, function, string (长字符串), userdata。这些对象存活在堆上，才是 GC 主要“追杀”的目标。 在 Lua 虚拟机源码中，几乎所有涉及内存分配的操作（如 lua_newtable, lua_pushstring）之后，都会调用一个检查宏：luaC_checkGC。\n1 2 3 4 5 6 #define luaC_checkGC(L) { \\ if (G(L)-\u0026gt;GCdebt \u0026gt; 0) { \\ luaC_step(L); \\ } \\ condchangemem(L,pre,pos); \\ } GCdebt (GC 债务)：这是一个核心概念。每当你分配 1 字节内存，GCdebt 就会增加 1。 判断逻辑：只要“债务”大于 0，Lua 就会认为“如果你制造了垃圾（或者申请了新内存），你就得负责清理一点垃圾”。 luaC_step：这就是执行一次 GC“步进”的函数。它不会跑完整个 GC 流程，而是只跑一小步（具体跑多远，由 stepmul 决定）。 控制 GC 的速率 了解了原理，我们就能看懂 collectgarbage 的两个参数了：\npause (暂停系数) 含义：GC的间歇率, 将 GCdebt 设置为一个巨大的负数来实现的, 默认值200（即 200%）。 逻辑：如果当前内存是 10MB，GC 结束后回收到 5MB。那么下一次 GC 启动的阈值是 5MB * 200% = 10MB。 值越小，GC 越勤快，内存占用越低，但 CPU 消耗越高。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 static void setpause (global_State *g) { l_mem threshold, debt; l_mem estimate = g-\u0026gt;GCestimate / 100; // 获取估算内存 l_mem pause = (g-\u0026gt;gcpause != 0) ? g-\u0026gt;gcpause : 200; // 默认 200 /* 计算我们要等待多少内存分配 */ threshold = (pause * estimate); /* 设置债务 = 估算值 - 阈值 因为 阈值 通常 \u0026gt; 估算值，所以这里 debt 是负数 */ debt = gettotalbytes(g) - threshold; luaE_setdebt(g, debt); } stepmul (步进倍率) 含义：控制 GC 扫描的速度。默认值 200(200%)。 逻辑：分配了 1 字节内存（增加了 1 字节债务）,GC 需要执行等同于 2 字节内存的工作量，才能把这 1 字节的债务“抵消”掉。 如果你发现内存飙升得比 GC 回收得快（Alloc \u0026gt; Free），说明 GC 跑慢了，需要调大 stepmul。 如果你发现游戏明显卡顿，可能是 GC 一次步进占用 CPU 太多，尝试调小 stepmul 让切片更细。 ","date":"2024-02-05T18:00:00+08:00","permalink":"/WBlog/p/lua-gc/","title":"Lua GC"},{"content":"Lua Table 源码剖析：混合数据结构的艺术 在 Lua 的设计哲学中，Table 是唯一的复合数据结构。它既要扮演数组（Array）的角色，又要胜任哈希表（Hash Map）的工作。这种“万金油”的特性背后，隐藏着非常精妙的设计思路。\n最近在研究 Lua 源码（基于 Lua 5.3/5.4 逻辑），整理了一些关于 Table 内部实现的笔记，在此记录并分享一下关于其数据结构、内存布局、冲突解决以及 Rehash 机制的探索。\n1. 核心数据结构：混合存储的基石 Lua Table 的高效由其底层的 struct Table 决定。从源码中我们可以清晰地看到，它并非单纯的哈希表，而是数组与哈希表的结合体。\n1.1 Table 结构体定义 1 2 3 4 5 6 7 8 9 10 11 typedef struct Table { CommonHeader; lu_byte flags; /* 1\u0026lt;\u0026lt;p means tagmethod(p) is not present (元方法缓存) */ lu_byte lsizenode; /* 哈希表长度的对数，即 hash_size = 2^lsizenode */ unsigned int alimit;/* 数组部分的“逻辑”大小 (即 sizearray) */ TValue *array; /* 数组部分指针 */ Node *node; /* 哈希桶数组起始指针 */ Node *lastfree; /* 指向哈希部分最后一个空闲位置，用于快速插入 */ struct Table *metatable; /* 元表 */ GCObject *gclist; } Table; 设计解读：\n双重存储：array 指针管理连续内存，用于存放整数键（1..n）；node 指针管理哈希桶，用于存放其他键或离散的整数键。 空间换时间：lastfree 指针的设计非常巧妙，它避免了每次插入时线性扫描寻找空位，将查找空闲位置的复杂度尽量降低。 lsizenode：哈希表的大小始终保持为 2 的幂次，这里存储的是幂次（log2），省去了存储实际大小的内存，计算时位移即可。 1.2 节点（Node）与键（Key） 哈希部分的节点结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 typedef union TKey { struct { TValuefields; struct Node *next; /* 链表法解决冲突，指向下一个冲突节点 */ } nk; TValue tvk; } TKey; typedef struct Node { TValue i_val; TKey i_key; } Node; 这里 Node 包含了 Key 和 Value。Key 是一个 union，为了内存对齐和访问效率，当发生哈希冲突时，通过 next 指针形成单向链表。\n2. 键的归属：数组还是哈希？ 当我们执行 t[k] = v 时，Lua 是如何决定把数据存在 array 还是 node 里的？\n2.1 整数键的“VIP 通道” 一般情况下，正整数键（如 t[1], t[100]）会优先尝试放入数组部分。但并非所有整数都会进入数组，必须满足利用率原则。\n核心规则：包含当前 key 的区间 $[1, 2^n]$ 内，非空元素数量必须大于 $2^{n-1}$（即利用率 \u0026gt; 50%）。\n源码佐证 (ltable.c)： Lua 通过 computesizes 函数来计算数组的最佳大小，代码清晰地展示了“\u0026gt; 50%”的判断逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 计算数组部分的最佳大小 */ static unsigned int computesizes (unsigned int nums[], unsigned int *narray) { int i; unsigned int twotoi; /* 2^i */ unsigned int a = 0; /* 统计小于 2^i 的元素个数 */ unsigned int na = 0; /* 最终落入数组部分的元素个数 */ unsigned int optimal = 0; /* 最佳数组大小 */ /* 循环遍历每个 2^i 区间 */ for (i = 0, twotoi = 1; twotoi/2 \u0026lt; *narray; i++, twotoi *= 2) { if (nums[i] \u0026gt; 0) { a += nums[i]; if (a \u0026gt; twotoi/2) { /* 核心判断：利用率 \u0026gt; 50% */ optimal = twotoi; na = a; } } } *narray = optimal; return na; } 举个例子： 如果你创建了一个表 t = {[1]=1, [1000]=1}。\n1 在数组部分。 1000 虽然是整数，但如果强行扩容数组到 1000，中间会有 998 个空洞，不满足 a \u0026gt; twotoi/2。因此，1000 会被当作普通 Key 扔进哈希部分。 2.2 哈希部分的“收容所” 以下情况 Key 会进入哈希表：\n非整数类型：字符串、Table、Userdata 等。 越界的整数：数值极大，或者像上面提到的过于稀疏的整数。 负数。 3. 冲突解决：Brent\u0026rsquo;s Method 的变种 这是 Lua Table 实现中最“骚”的操作之一。\n通常哈希表解决冲突用的是开链法（Open Addressing with Chaining），但 Lua 为了节省内存，并没有在这个链表之外单独分配内存，而是直接利用哈希桶数组中未被使用的槽位。\n3.1 插入逻辑（Insert） 当我们要插入一个新的 Key (new_key)，算出它应该在的位置 main_pos，却发现那里已经有“人”了 (old_node)，Lua 会根据 old_node 的身份采取不同策略。\n源码佐证 (luaH_newkey)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* 插入新键的核心逻辑 (简化版) */ TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) { Node *mp; if (ttisnil(key)) luaG_runerror(L, \u0026#34;table index is nil\u0026#34;); /* 1. 计算主位置 (Main Position) */ mp = mainposition(t, key); /* 2. 如果主位置已被占用 */ if (!ttisnil(gval(mp)) || mp == dummynode) { Node *othern; /* 获取空闲位置 (lastfree) */ Node *f = getfreepos(t); if (f == NULL) { /* 没位置了？扩容 */ rehash(L, t, key); return luaH_set(L, t, key); } /* 计算占位者(old_node)原本该在的主位置 */ othern = mainposition(t, keyfromval(mp)); if (othern != mp) { /* Case A: 鸠占鹊巢 -\u0026gt; 把 old_node 赶到 free pos */ while (othern + gnext(othern) != mp) othern += gnext(othern); /* 找到指向 mp 的前驱 */ gnext(othern) = cast_int(f - othern); /* 修正链表指向新位置 f */ *f = *mp; /* 搬迁数据 */ /* 腾出 mp 给新键，因为 mp 是新键的主位置 */ gnext(mp) = 0; setnilvalue(gval(mp)); } else { /* Case B: 原住民冲突 -\u0026gt; 新键只能去 free pos */ if (gnext(mp) != 0) gnext(f) = cast_int((mp + gnext(mp)) - f); /* 头插法：链在 mp 后面 */ else gnext(f) = 0; gnext(mp) = cast_int(f - mp); mp = f; } } setnodekey(L, \u0026amp;mp-\u0026gt;i_key, key); return gval(mp); } 情况 A：鸠占鹊巢 如果 old_node 是被挤到这里的（即 othern != mp）。 操作：Lua 把它挪到 lastfree，把 main_pos 抢回来给 new_key。 目的：保证 new_key 这种“原住民”能直接找到位置，减少后续查找的开销。 情况 B：原住民冲突 如果 old_node 本来就该待在这里。 操作：new_key 去 lastfree，并链接在 old_node 后面。 这种机制被称为 Chained Scatter Table，它充分利用了数组空间，避免了由于大量微小对象分配导致的内存碎片。\n4. 动态扩容：Rehash 的艺术 Table 的空间不是固定的。当空间不足或利用率失衡时，会触发 Rehash。\n4.1 触发时机 插入新键且空间已满：当我们赋值一个新键，而 Table 既没有数组空间，也没有哈希空位时。 注意：将某个 Key 置为 nil 不会立即触发 Rehash（为了防止频繁的内存抖动）。只有在空间不足需要重新评估时，才会回收 nil 占用的空间。 4.2 Rehash 的三部曲 Rehash 是一个相对昂贵的操作，Lua 必须一次性重新计算数组和哈希两部分的最佳大小。\n统计（Counting）： 遍历整个 Table（包括现有的 Array 和 Hash 部分），统计所有正整数键的数量，并按 $2^n$ 的区间（1-2, 3-4, 5-8\u0026hellip;）进行分桶统计。同时统计非整数键的总数。 定界（Sizing）： 计算数组部分的最佳大小 sizearray。 算法：找到最大的 $N$（$2$ 的幂），使得 $[1, N]$ 区间内的整数键数量 $\\ge N/2$。 凡是小于等于 $N$ 的整数放入新数组，其余放入新哈希表。 搬迁（Relocation）： 申请新的 Array 和 Hash 内存块。 将数据搬运过去（重新计算哈希值）。 释放旧内存。 这解释了为什么 Lua Table 既能像 C 数组一样紧凑高效，又能像 Python Dict 一样灵活。\n5. 迭代器的秘密：pairs 与 ipairs 我们在写 Lua 时常用的两种遍历方式，其底层性能差异巨大。\n5.1 ipairs：序列专用 ipairs 是为**序列（Sequence）**量身定做的。\n逻辑：维护一个内部计数器 i，从 1 开始递增。 寻址：Lua 内部会先判断 i 是否在 array 的范围内。 源码佐证 (luaH_getint)： 这是整数查找的入口函数，清晰展示了“先查数组，再查哈希”的逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const TValue *luaH_getint (Table *t, lua_Integer key) { /* 1. 数组部分快速查找 (Fast Path) */ /* 这里的 alimit 就是数组的逻辑大小 */ if (l_castS2U(key) - 1 \u0026lt; t-\u0026gt;alimit) return \u0026amp;t-\u0026gt;array[key - 1]; else { /* 2. 哈希部分查找 (Slow Path) */ Node *n = hashint(t, key); for (;;) { if (ttisinteger(gkey(n)) \u0026amp;\u0026amp; ivalue(gkey(n)) == key) return gval(n); /* 找到了 */ else { int nx = gnext(n); if (nx == 0) break; n += nx; /* 沿着冲突链查找 */ } } return luaO_nilobject; } } 在范围内：直接通过指针偏移 array[i] 读取，这几乎就是 C 语言访问数组的速度，极快。 不在范围内：才去查 Hash 表。 5.2 pairs：全量遍历 pairs 使用的是 lua_next 函数。\n流程： 先遍历数组部分：从下标 0 到 sizearray 线性扫描。 再遍历哈希部分：从哈希桶的第一个位置扫描到最后一个位置。 顺序问题： 对于纯数组表（如 {10, 20, 30}），因为只扫描数组部分，输出看起来是有序的。 一旦涉及哈希部分，顺序就是乱序的。这是因为 Key 在哈希表中的物理位置取决于 Hash 算法和冲突时的插入顺序，与逻辑顺序无关。 避坑指南：\n不要依赖 pairs 的遍历顺序，除非你确认表是纯数组且尚未发生过复杂的 Rehash。\n6. 总结 Lua Table 的源码实现体现了极强的工程实用主义：\n混合结构平衡了数组的 $O(1)$ 访问和哈希表的稀疏灵活性。 50% 利用率原则保证了数组空间不会被过度浪费。 lastfree 冲突解决最大化利用了预分配内存，减少了 malloc 调用的开销。 ","date":"2024-02-05T18:00:00+08:00","permalink":"/WBlog/p/lua-table/","title":"Lua Table"},{"content":"Lua 源码手记：数据类型与隐藏的 GC 对象 最近在啃 Lua 的源码，主要想搞清楚一个问题：当我们写下 local a = 1 随后又写 a = \u0026quot;hello\u0026quot; 时，Lua 虚拟机底层到底发生了什么？\n作为一个 Lua 开发者，我们习惯了“变量无类型，值有类型”的自由。但在 C 语言编写的虚拟机底层，内存是严苛且静态的。Lua 是如何在一个静态的 C 结构体中塞进千变万化的动态类型的？哪些数据是“活”在栈上的，哪些又是需要垃圾回收器（GC）费心照顾的？\n本文将带你通过“显微镜”视角，从底层的 TValue 结构开始，重新审视 Lua 的数据类型系统与内存管理策略。\n一、 源码揭秘：万物之容器 TValue 在 Lua 虚拟机中，并没有“整数变量”或“字符串变量”的概念。无论是全局变量、局部变量，还是 Table 中的一个槽位，在底层 C 源码中，它们都由一个统一的数据结构表示：TValue。\nTValue 的设计完美体现了 Lua 的核心哲学：Tagged Union（带标签的联合体）。\n1.1 核心结构定义 我们可以将 TValue 想象成一个标准化的“通用快递盒”，它由两部分组成：\n标签 (Tag)：说明书，标记盒子里装的是什么类型。 值 (Value)：实际货物，或者指向货物的取货单（指针）。 让我们看看 Lua 5.3+ 源码中的核心定义（位于 lobject.h）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 通用值联合体：同一时间只能存一种数据，保证内存紧凑 */ typedef union Value { GCObject *gc; /* collectable objects: 复杂对象（Table, String...）存指针 -\u0026gt; 指向堆内存 */ void *p; /* light userdata: 存纯指针 -\u0026gt; 直接存地址 */ int b; /* boolean: 存 0 或 1 -\u0026gt; 直接存整数 */ lua_CFunction f; /* light C functions: 轻量级 C 函数 */ lua_Integer i; /* integer numbers: 整数 */ lua_Number n; /* float numbers: 浮点数 */ } Value; /* Lua 中的通用值结构 */ #define TValuefields Value value_; int tt_ typedef struct TValue { TValuefields; } TValue; 1.2 它是如何工作的？ 当你写 local a = 10 时，Lua 虚拟机做的事情是：\n找到 a 对应的栈槽位（一个 TValue 内存块）。 将 tt_ (标签) 设为 LUA_TNUMINT。 将 value_.i (数据) 设为 10。 当你随后写 a = {} 时：\n虚拟机在堆内存中创建一个新的 Table 对象。 将 a 的 tt_ 更新为 LUA_TTABLE。 将 value_.gc 更新为指向那个 Table 的指针。 这种设计使得 Lua 的变量可以承载任何类型，因为它们本质上只是一个携带了类型标签的容器。\n二、 Lua 的 8 种基本数据类型：内存视角 基于 TValue 的存储方式，我们可以将 Lua 暴露给开发者的 8 种数据类型分为三大类。这直接关系到赋值操作的性能和 GC 的压力。\n1. 值类型 (Value Types) —— 栈上的原住民 这些类型的数据非常小，直接存储在 TValue 结构体内部。\nnil (空)：表示“无效值”。全局变量默认值。赋值 nil 等同于删除。 boolean (布尔)：只有 true 和 false。 注意：Lua 中只有 false 和 nil 为假，数字 0 是真。 number (数值)： Lua 5.3+ 分为 Integer (64位整型) 和 Float (双精度浮点)。 VM 会自动处理转换，通常无需感知。 light userdata (轻量用户数据)： 特例：它本质上是一个纯粹的 C 指针 (void *)。Lua 把它当作一个数字处理，不管理它的生命周期（生死由 C 端代码负责）。这是高性能交互的利器。 2. GC 类型 (GCObjects) —— 堆上的住客 这些类型数据量大且结构复杂，TValue 只存指针（value_.gc）。\nstring (字符串)： 不可变字符序列。 String Interning (字符串驻留)：Lua 会对短字符串进行唯一化处理，相同内容的短字符串在全局只有一份内存，比较时只需比较指针地址，速度极快。 table (表)： Lua 唯一的数据结构。 既是数组（Array，下标从1开始），也是字典（Hash Map）。 function (函数)： 第一类值（First-class）。 包含 C 函数和 Lua 函数（闭包）。 thread (线程)： 协程 (Coroutine) 的实现基础。 userdata (完全用户数据)： 由 Lua 虚拟机分配内存的一块原始内存区域，支持 __gc 元方法析构。 三、 谁在参与 GC？（内存管理揭秘） 在 Lua 中，并不是所有变量都需要垃圾回收器（Garbage Collection, GC）操心。\n3.1 GCObject 的秘密 所有需要被 GC 管理的对象，在 C 层面都有一个共同的头部，叫做 CommonHeader。\n1 2 3 4 5 6 /* 所有 GC 对象通用的头部 */ #define CommonHeader\tGCObject *next; lu_byte tt; lu_byte marked struct GCObject { CommonHeader; /* 包含：链表指针、类型标签、GC 颜色标记 */ }; 这就解释了为什么 Lua 可以统一管理不同类型的对象：因为它们强转为 GCObject* 后，头部结构是一样的，GC 只需要扫描这个头部链表即可。\n3.2 区分标准 不参与 GC：nil, boolean, number, light userdata。它们随栈帧生灭，无需 GC 介入。 参与 GC：string, table, function, userdata, thread。它们在堆上分配，需要通过标记-清除（Mark-and-Sweep）算法回收。 四、 隐形的 GC 对象：Proto 与 UpVal 除了上述我们在 Lua 代码中能直接操作的类型外，Lua 虚拟机底层还有两个非常关键的内部对象也是由 GC 管理的。理解它们，是掌握 Lua 闭包 (Closure) 机制的钥匙。\n1. Proto (函数原型) —— 静态的蓝图 你可以把 Proto 看作是**“函数的编译模具”**。\n它是什么：当 Lua 编译器编译一段代码时，生成的字节码（Bytecode）、常量表（Constants）、调试信息等静态数据，都被打包存储在一个 Proto 对象中。 生命周期：虽然它是静态的，但当你使用 load 加载一段代码块时，系统会生成对应的 Proto。如果这个模块被卸载，或者没有任何闭包再使用这个模具，Proto 就需要被回收。 2. UpVal (上值对象) —— 闭包的灵魂 这是 Lua 闭包机制最精妙的地方。UpVal 是独立于函数栈帧存在的对象，用于存储闭包捕获的外部局部变量。\n为什么需要它？ 当一个函数返回时，它的栈帧会被销毁，原本存在栈上的局部变量也就消失了。如果内部函数（闭包）还引用了这个变量，怎么办？ Open vs Closed 状态： Open (开放)：当父函数还在运行时，被捕获的变量还在栈上。此时 UpVal 只是一个指针，指向栈上的那个位置。 Closed (关闭)：当父函数返回，栈即将销毁时，Lua 会将变量的值复制到 UpVal 对象内部（堆内存），并将 UpVal 指针指向自己。这就实现了“变量逃逸”。 公式类比：\nLua Function (运行时闭包) = Proto (静态代码逻辑) + UpVals (动态环境上下文)\n这就是为什么两个闭包可以使用同一份代码（同一个 Proto），却拥有不同的状态（不同的 UpVals）。\n五、 总结与性能建议 通过重新审视 TValue 和 GC 对象，我们可以得出一些写出高性能 Lua 代码的原则：\n赋值开销： number/boolean 赋值是内存拷贝（极快）。 table/function 赋值是指针拷贝（极快）。 但是，创建 table ({}) 或闭包 (function() end) 是堆内存分配，相对较慢。 Light Userdata 的妙用： 如果你只需要在 Lua 里持有一个 C++ 对象的句柄，且生命周期由 C++ 管理，请务必使用 light userdata。它可以完全避开 GC 的扫描和追踪开销。 闭包的代价： 每创建一个新的闭包，不仅会创建一个 Function 对象，如果涉及新的外部变量捕获，还可能创建新的 UpVal 对象。在极高频调用的场景下（如游戏每帧 Update），应尽量避免在循环内创建匿名函数。 GC 压力： 字符串拼接（产生新 String 对象）和表的频繁创建销毁是 GC 卡顿的两大元凶。在性能敏感区，复用 Table（Object Pooling）永远是王道。 ","date":"2024-02-05T18:00:00+08:00","permalink":"/WBlog/p/lua-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8Egc%E5%AF%B9%E8%B1%A1/","title":"Lua 数据类型与GC对象"},{"content":"很幸运生活在一个技术爆炸的时代, 感觉未来充满着可能性\n在这里展示我的生活, 我的思考, 我的成长\n","date":"2024-01-29T00:00:00Z","permalink":"/WBlog/p/hello-world/","title":"hello world"}]