[{"content":"Lua 5.4 引入的分代垃圾回收（Generational GC）,相比于 Lua 5.3 的增量式 GC 专注于“降低停顿时间（Latency）”，Lua 5.4 的分代 GC 旨在解决“高吞吐量（Throughput）”场景下的性能瓶颈。特别是对于那些每一帧都产生大量临时对象（Short-lived objects）的游戏或高并发服务，分代 GC 能带来巨大的性能提升。\n分代假设 分代假设（Generational Hypothesis） 认为：“绝大多数对象在创建后很快就会死亡。”\n在 Lua 5.3 的增量 GC 中，哪怕我们把 GC 拆分成了很多小步，但为了完成一轮完整的 GC 周期，收集器最终还是需要遍历整个堆（或者至少是大部分活跃对象）。如果堆中有几百万个长期存活的对象（比如加载的配置表、全局注册表），每次 GC 都要去确认它们“还在不在”，这本身就是一种巨大的算力浪费。\nLua 5.4 的分代模式试图达成以下目标：\n忽略老年代：默认老年代对象是“不死”的，除非有证据表明它们引用了新对象。\n聚焦年轻代：集中火力快速扫描和清理新创建的对象。\n零拷贝（Non-Moving）：作为嵌入式语言，Lua 需要保持 C API 的指针稳定性，因此不能像 Java 或 Go 那样通过物理移动内存来整理堆。\n这种设计使得 Lua 5.4 在处理短命对象（如临时字符串、闭包、表）密集的场景下，性能比 5.3 提升显著，同时保持了极低的延迟。\n对象状态的深度解析 在分代模式下，Lua 利用 GCObject 头部的标记位（Mark bits）构建了一个精细的状态机。为了更平滑地管理晋升，Lua 5.4 实际上将老年代细分为了两个阶段。\n状态全景图 G_NEW (Young):\n定义: 所有新创建的对象默认都是这个状态。\n命运: 在 Minor GC 中，要么死掉，要么变成 Survivor。\nG_SURVIVAL:\n定义: 经历了一次 Minor GC 仍然存活，但还没“老”够两轮的对象。\n作用: 这是一个缓冲带。很多对象可能刚好活过了一次 GC（例如跨帧存在的临时对象），如果直接晋升为老年代，下次 GC 就得扫描老年代或者等待 Major GC 才能回收它，成本太高。给它第二次机会，能有效减少“假冒老年代”的数量。\nG_OLD0 (The \u0026ldquo;Really\u0026rdquo; Old):\n定义: 真正的老年代。\n特征: 颜色为黑色（Black）。GC 在 Minor Collection 期间完全无视它们。\nG_OLD1 (Old but visited):\n定义: 这也是老年代，但在当前的 GC 周期中，它们是“刚晋升”上来的，或者有着特殊的标记意义。在源码中，G_OLD0 和 G_OLD1 经常通过位运算切换，用于区分不同周期的老年代，防止在同一个周期内重复处理。 G_TOUCHED (The Remembered Set):\n定义: 一个被“弄脏”的老年代对象。\n触发: 当 old_obj[key] = new_obj 发生时，old_obj 会从 G_OLD 变为 G_TOUCHED。\n存储: 它们会被链入 grayagain 列表。\n状态流转图 1 2 3 4 [ G_NEW ] --(Minor GC 存活)--\u0026gt; [ G_SURVIVAL ] --(下一次 Minor GC 存活)--\u0026gt; [ G_OLD1 ] --\u0026gt; [ G_OLD0 ] ^ | | | +----(被引用)----\u0026lt; [ G_TOUCHED ] \u0026lt;----(写屏障触发)-------------------------+ 关键机制：向前写屏障 (Forward Write Barrier) 分代 GC 的核心难题是：如何知道哪些老年代对象引用了年轻代对象？ 如果不解决这个问题，回收年轻代时就必须扫描所有老年代对象，这会极其缓慢。\nLua 使用 向前写屏障（Forward Write Barrier） 来解决。\n当执行 t[k] = v 时，如果 t 是老年代（Black），而 v 是新对象（White/Young）。 触发屏障：luaC_barrier_。 状态变更： t 被标记为 G_TOUCHED。 加入列表： t 被放入 grayagain 列表（在这个上下文中，它被用作待扫描的根集合的一部分）。 屏障触发逻辑 当执行 lua_settable 或类似操作（t[k] = v）时，虚拟机会调用 luaC_barrier_。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 伪代码解析 lgc.c 中的 luaC_barrier_ void luaC_barrier_ (lua_State *L, GCObject *o, GCObject *v) { // o 是父对象 (table), v 是子对象 (value) // 只有当父对象是老年代 (isold)，且子对象是新对象 (iswhite) 时才触发 if (isold(o) \u0026amp;\u0026amp; iswhite(v)) { // 标记 1: 将父对象标记为 TOUCHED // 这意味着它不再是纯粹的 OLD，它持有对 Young 的引用 setage(o, G_TOUCHED); // 标记 2: 将其放入 grayagain 列表 // grayagain 本质上就是 \u0026#34;Remembered Set\u0026#34; (记忆集) linkgclist(o, g-\u0026gt;grayagain); } } 为什么叫“向前”？ Lua 使用 向前写屏障（Forward Write Barrier） 来解决。这与增量 GC 中使用的“向后写屏障（Backwards Barrier，将父节点颜色改回灰色）”不同。\n在增量 GC 中，如果我们把黑色对象改回灰色（向后），GC 就需要重新扫描它。但在分代 GC 中，我们不希望重新扫描整个对象（如果它很大）。 Lua 的处理方式其实更接近于“把这个老年代对象暂时看作根节点”。在 Minor GC 开始时，它是扫描的起点之一。\n次级回收 (Minor Collection) 的详细流程 次级回收（Minor Collection）的目标是：只清理年轻代对象，且必须是原子操作（不可中断，但由于只扫描年轻代和被触碰的老年代，速度极快）。\n触发时机 由 genminormul 参数控制。默认情况下，当新分配的内存达到上次存活内存的 20% 时触发。\n步骤详解 准备与根扫描 (Mark Roots):\nGC 扫描主线程栈、全局注册表 (Registry) 等根节点。\n注意：这里只标记根节点直接指向的年轻代对象。\n处理记忆集 (Scan GrayAgain / Touched):\n这是分代 GC 能够成立的基石。\nGC 遍历 grayagain 列表。这里面全是 G_TOUCHED 的老对象。\n关键逻辑: 如果一个老对象在 grayagain 里，GC 会扫描它引用的所有子对象。如果子对象是 G_NEW，则将其标记为活跃。\n状态恢复: 扫描完后，这个老对象通常会被改回 G_OLD 状态。如果它之后又被修改，写屏障会再次捕获它。\n递归追踪 (Trace):\n从上述步骤产生的灰色对象开始遍历。\n截断机制 (The Cut-off): 遍历过程中，一旦遇到 isold(obj) 为真的对象，立刻停止深入。因为老年代对象被默认认为是“这就到头了，不用管它的子节点（除非它在 grayagain 里）”。\n这保证了遍历仅限制在年轻代对象图中。\n清扫与晋升 (Sweep and Promote):\n此时，所有未被标记的年轻代对象都是垃圾。Lua 遍历全局对象链表（这在 Lua 5.4 中通过优化，不再遍历整个 allgc，而是利用指针操作高效处理）： 死亡对象（Dead Young）： 既不是老年代，也没被标记为活跃。 -\u0026gt; 释放内存。 幸存对象（Survivor）： 它是年轻代，但被标记为活跃。 如果它之前是 G_NEW，将其改为 G_SURVIVAL（给它第二次机会证明自己是垃圾）。 如果它之前是 G_SURVIVAL，将其晋升为 G_OLD（晋升）。 老年代对象（Old）： 忽略，不处理。 逆序链表与哨兵 这是 Lua GC 实现中最优雅的部分。Lua 不需要移动内存块来整理堆，它通过巧妙的链表操作实现了逻辑上的“分代移动”。\n数据结构：时间逆序链表 Lua 的全局对象链表 allgc 是按时间逆序排列的。因为新对象总是插入到链表头部。\n1 2 3 4 5 6 7 8 9 内存地址: High \u0026lt;--------------------------------------\u0026gt; Low 逻辑链表: HEAD (g-\u0026gt;allgc) | v [ 新对象 A ] -\u0026gt; [ 新对象 B ] -\u0026gt; [ 幸存者 S ] -\u0026gt; [ 老对象 O1 ] -\u0026gt; [ 老对象 O2 ] -\u0026gt; NULL (G_NEW) (G_NEW) (G_SURVIVAL) (G_OLD) (G_OLD) ^ | g-\u0026gt;survival (哨兵指针) g-\u0026gt;survival 指针指向了上一次 GC 时的边界。换句话说，g-\u0026gt;survival 之后的所有对象，在本次 Minor GC 开始前就已经存在了，它们要么是幸存者，要么是老年代，反正绝不是 G_NEW。\n截断式清扫 (Sweep) 由于这种排列特性，Minor GC 的清扫阶段不需要遍历整个链表。\nSweep 逻辑演示 (伪代码):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 GCObject **p = \u0026amp;g-\u0026gt;allgc; GCObject *curr; GCObject *limit = g-\u0026gt;survival; // 我们的终点站 // 只要还没碰到老年代的边界，就一直循环 while ((curr = *p) != limit) { if (is_marked(curr)) { // === 存活对象处理 === // 晋升逻辑： // 如果是 G_NEW -\u0026gt; 变成 G_SURVIVAL // 如果是 G_SURVIVAL -\u0026gt; 变成 G_OLD1 (正式晋升) promote_age(curr); // 清除标记位，为下一次 GC 做准备 (变为白色) make_white(curr); // 指针步进：这个对象留下了，检查下一个 p = \u0026amp;curr-\u0026gt;next; } else { // === 死亡对象处理 === // 这是一个垃圾对象！ GCObject *dead = curr; // 链表摘除操作： // *p 指向 curr-\u0026gt;next，直接跳过 current *p = curr-\u0026gt;next; // 释放内存 freeobj(L, dead); // 注意：这里 p 不动，因为 *p 已经指向了原本的 next， // 下次循环会直接检查那个新对象。 } } // 循环结束！ // 此时 *p 等于 limit。 // 后面那几百万个老年代对象完全不需要访问，Cache 友好度满分。 链表剪接与状态更新 在 Sweep 结束后，我们需要设定新的边界。\n假设在上面的例子中，新对象 A 死了，新对象 B 活了。 现在的链表变成了： [ B (Survival) ] -\u0026gt; [ S (Old) ] -\u0026gt; [ O1 (Old) ] ...\n此时，g-\u0026gt;survival 指针需要更新，指向现在的表头 g-\u0026gt;allgc。 这一步操作瞬间完成了“代”的切换。 今天幸存下来的对象，在下一次 GC 时就会位于 g-\u0026gt;survival 指针的后面，成为受保护的老年代。\n什么时候会“崩”？(回退到 Major GC) 分代 GC 虽好，但在某些模式下会失效，甚至比普通 GC 更慢。Lua 5.4 引入了回退机制。\n触发 Major GC 的条件 老年代膨胀 (Memory Growth):\n通过 genmajormul 参数控制（默认 100%）。\n如果老年代的内存大小比上一次 Major GC 时翻了一倍，说明老年代本身在快速增长，Minor GC 已经无法控制内存总量了，必须做一次全量清理。\nBad Touch (G_TOUCHED 过多):\n这是最阴险的性能杀手。\n原理: Minor GC 的成本 = 扫描年轻代 + 扫描 Touched 老年代。\n如果 grayagain 列表非常长，G_TOUCHED 的对象太多了。这意味着老年代频繁指向新对象（例如把一个巨大的老表当成缓冲区不断写入新数据）,Minor GC 就不再是“Minor”了，它会退化成一次接近全量的扫描。\nLua 内部会计数 grayagain 的大小，如果它超过了总内存的一定比例，就会强制转为 Major GC。\n此时，Lua 会触发一次 Major Collection。这本质上是一次完整的标记-清除循环：\n扫描所有对象。 清理所有死对象（无论老少）。 重置所有存活对象为 G_OLD。 清空 grayagain 列表。 \u0026ldquo;Bad Touch\u0026rdquo; 代码示例 这就是所谓的“把老年代当缓冲区用”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 -- 场景：config 是一个常驻内存的老年代 Table local config = { data = {} } -- 这是一个高频调用的函数，比如每帧调用 function onUpdate() -- 这是一个典型的 Bad Touch 模式 -- 我们不断地创建新表 {}，并把它赋值给老表 config 的字段 -- 触发写屏障：config 变黑 -\u0026gt; 变灰 (TOUCHED) -\u0026gt; 加入 grayagain config.last_frame_data = { x = 1, y = 2 } -- 这种写法会导致 config 表在每一次 Minor GC 中都被扫描！ -- 如果 config 表很大（比如有几万个字段），GC 耗时会瞬间飙升。 end 优化建议: 如果必须频繁更新，尽量复用年轻代对象，或者将变动的数据隔离在一个独立的年轻代 Table 中，不要让它频繁污染巨大的老年代根节点。\n实际应用中的问题 分代回收的次级回收周期以及全量回收都是是 Stop-the-World\u0026quot;（全停顿） 的策略。 “脏”老年代过多 (内存过高)时的性能问题 在对延迟极度敏感的场景（如战斗逻辑、高频服务端）中，是不能接受了, 会导致大内存服务的卡顿问题\n优化策略 在不同内存使用情况下采用最适合的垃圾回收方式，以优化性能\n在低内存时(比如500M)使用分代回收，享受他带来的性能提升 当内存使用较高时，切换到增量模式，通过周期性地执行小步骤的垃圾回收，避免一次性长时间的GC暂停 ","date":"2026-02-08T18:32:29+08:00","permalink":"/WBlog/p/lua-%E5%88%86%E4%BB%A3-gc/","title":"Lua 分代 GC"},{"content":"Lua GC ：三色标记、增量回收与写屏障 从 Stop-the-World 到增量 Lua 5.0：简单的代价 在 Lua 5.0 时代，GC 算法非常朴素：双倍阈值，全量回收。\n逻辑：当内存使用量达到上次 GC 后的两倍时，虚拟机暂停所有业务逻辑，跑一遍完整的“标记-清除”。 后果：这就是著名的 Stop-the-World (STW)。如果你的 Lua 内存占用了 1GB，GC 触发的那一瞬间，整个游戏或服务可能会卡顿几百毫秒甚至更久。 Lua 5.1+：三色增量标记（Tri-color Incremental Mark \u0026amp; Sweep） 为了解决卡顿，Lua 5.1 引入了增量 GC。GC 过程与业务代码交替运行。\n为了实现“可中断、可恢复”的扫描，Lua 引入了三色标记法。\n核心算法：三色标记与双白设计 GC 的本质是从根节点（_G、Registry、栈）出发，找到所有可达对象。在增量扫描过程中，对象被标记为三种颜色：\n颜色的含义 ⚪ 白色 (White)： 含义：当前还未被 GC 访问到的对象，或者已死亡的对象。 初始状态：所有新创建的对象默认为白色。 结局：如果 GC 结束后还是白色，说明不可达，回收。 ⚫ 黑色 (Black)： 含义：已扫描完毕。该对象及其引用的所有子对象都已经被访问过了。 特性：GC 这一轮不会再回头看它。 🔘 灰色 (Gray)： 含义：待处理。该对象已被访问（从白色变成了灰色），但它引用的子对象还没扫描完。 作用：灰色是当前扫描的边缘（Frontier），保存在一个链表中。 巧妙的“双白”设计 (The Two Whites) 我在研究源码时发现一个有趣的细节：Lua 的白色其实细分为 White1 和 White2。这是为了解决什么问题？\n场景： GC 标记阶段已经快结束了（大部分是黑色），此时业务代码突然创建了一个新对象。\n新对象默认是白色。 如果不加区分，在接下来的“清除阶段”，GC 会认为这个白色的新对象是“没被引用的垃圾”并把它回收掉——这会导致严重 Bug。 解决方案： Lua 使用一个全局的位掩码 CurrentWhite。\n本轮 GC：只回收标记为“旧白色”的对象。 新创建对象：标记为“新白色”（CurrentWhite）。 结果：新对象在本轮 GC 中被视为“安全”，留到下一轮再处理。在清除阶段结束后，Lua 会轮转 CurrentWhite 的值。 状态机的流转：GC 的生命周期 Lua 的增量 GC 是通过一个状态机驱动的。每次调用 luaC_step，GC 就会向前推进一步。以下是主要的阶段：\n① GCSpause (暂停/初始化) GC 的起点。\n将根节点（主线程、全局表 _G、Registry 等）标记为灰色，并加入灰色链表。 此时，通过根节点的一波操作，我们有了第一批待扫描的灰色对象。 ② GCSpropagate (传播 - 最耗时的阶段) 这是“增量”体现最明显的地方。\n操作：从灰色链表中弹出一个对象，将其标记为黑色，然后遍历它引用的所有子对象： 如果是白色，将其染成灰色并加入链表。 控制：这个过程不是一次性做完的，而是受 gcstepmul 控制，每次只处理一部分就暂停，把 CPU 让给业务逻辑。 ③ GCSatomic (原子阶段 - 必须一次做完) 这是这一轮 GC 中唯一需要 Stop-the-World 的时刻，但通常很快。\n目的：因为 Propagate 阶段是并发的，业务代码可能在此期间修改了引用（比如把一个白色对象赋值给了一个已经黑色的 Table）。如果不修正，那个白色对象会被误删。 操作： 重新遍历“灰名单”（GrayAgain，由写屏障产生，详见下文）。 扫描弱引用表（Weak Tables）。 完成所有剩余的标记工作。 ④ GCSsweepstring (字符串清理) 特点：Lua 的短字符串是单独管理的（通常存储在全局哈希表中）。因为字符串没有子引用，清理非常快，直接从哈希表中移除未标记的字符串。 ⑤ GCSsweep (普通对象清理) 操作：遍历所有 GCObject 链表。 如果是黑色：说明活着，重置为当前白色（为下一轮做准备）。 如果是旧白色：说明死了，free 掉内存。 ⑥ GCSfinalize (终结) 处理所有实现了 __gc 元方法的 Userdata。这些对象不会立即释放，而是会被放入一个单独的列表，等待虚拟机调用它们的析构函数。 并发下的“黑指向白”与写屏障 在 GCSpropagate 阶段，GC 和业务逻辑是交替运行的。这就带来了一个严重的数据竞争问题。\n问题场景：\nGC 标记了 Table A 为黑色（认为 A 已经扫描完了）。 业务代码执行 A.x = B，其中 B 是一个白色对象。 因为 A 已经是黑色，GC 不会再扫描它。 后果：B 作为一个被引用的对象，却因为没被扫描到，保持白色。在清除阶段，B 会被当垃圾回收，导致 A.x 变成了野指针！ 解决方案：写屏障 (Write Barrier) 为了维护**“黑色对象不能指向白色对象”**这一不变量（Invariant），Lua 在每次修改引用（table set/assignment）时，会触发写屏障。\n写屏障有两种主要形式：\n1. 前进屏障 (Forward Barrier) - \u0026ldquo;把白色染灰\u0026rdquo; 如果你把白色对象 B 赋给黑色对象 A，屏障会立即把 B 染成灰色。\n意义：既然 A 引用了 B，那 B 肯定是有用的，赶紧把 B 拉进待扫描清单。 应用：通常用于将新对象赋值给老对象时。用于 Closure (Upvalues)、Userdata 等。因为这些对象通常不像 Table 那样频繁修改引用。 2. 后退屏障 (Backward Barrier) - \u0026ldquo;把黑色回退变灰\u0026rdquo; 如果你把白色对象 B 赋给黑色对象 A，屏障把 A 变回灰色，扔进 grayagain 列表。\n意义：A 你虽然扫过了，但你现在又有了新欢，GC 稍后得回头再查你一次。 应用：通常用于 Table 等容器。这是因为 Table 容易频繁变动，如果用前进屏障（把子对象变灰），下次 Table 再变动时又要触发屏障；而把 Table 变灰后，它就留在 Gray 链表中，之后再往里面塞白色对象就不需要触发屏障了（因为父对象已经是灰的了）。 源码窥探 让我们看看 Lua 内部宏 luaC_barrier 的简化逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 伪代码逻辑：写屏障 */ #define luaC_barrier(L, p, v) { \\ /* p 是父对象(Table)，v 是子对象(Value) */ \\ if (isblack(p) \u0026amp;\u0026amp; iswhite(v)) { \\ /* 触发屏障：黑色指向了白色 */ \\ luaC_barrier_(L, obj2gco(p), obj2gco(v)); \\ } \\ } void luaC_barrier_ (lua_State *L, GCObject *p, GCObject *v) { /* 保持黑白不变性 */ if (isdead(L, v)) return; // 已经死的不管 // 策略：通常是将 v (子对象) 标灰 (Forward Barrier) // 或者将 p (父对象) 放入 grayagain 列表 (Backward Barrier) reallymarkobject(L, v); } 正是这个 luaC_barrier，保证了增量 GC 的正确性。它就像一个监视器，拦截了所有的赋值操作。\nGC触发的时机 假设我们执行以下代码：\n1 local i = 1234 这行代码会触发 GC 吗？答案是不会。\n根据 Lua 的内存模型（如上文 TValue 结构所示）：\n值类型（Value Types）：如 nil, boolean, number (integer/float)。这些数据直接存放在 Lua 栈的 TValue 结构体中。它们随着栈帧的销毁而自动消失，不涉及堆内存分配（malloc），因此不计入 GC 的债务（GCdebt），自然也不会触发 GC 步进。 引用类型（Reference Types）：如 table, function, string (长字符串), userdata。这些对象存活在堆上，才是 GC 主要“追杀”的目标。 在 Lua 虚拟机源码中，几乎所有涉及内存分配的操作（如 lua_newtable, lua_pushstring）之后，都会调用一个检查宏：luaC_checkGC。\n1 2 3 4 5 6 #define luaC_checkGC(L) { \\ if (G(L)-\u0026gt;GCdebt \u0026gt; 0) { \\ luaC_step(L); \\ } \\ condchangemem(L,pre,pos); \\ } GCdebt (GC 债务)：这是一个核心概念。每当你分配 1 字节内存，GCdebt 就会增加 1。 判断逻辑：只要“债务”大于 0，Lua 就会认为“如果你制造了垃圾（或者申请了新内存），你就得负责清理一点垃圾”。 luaC_step：这就是执行一次 GC“步进”的函数。它不会跑完整个 GC 流程，而是只跑一小步（具体跑多远，由 stepmul 决定）。 控制 GC 的速率 了解了原理，我们就能看懂 collectgarbage 的两个参数了：\npause (暂停系数) 含义：GC的间歇率, 将 GCdebt 设置为一个巨大的负数来实现的, 默认值200（即 200%）。 逻辑：如果当前内存是 10MB，GC 结束后回收到 5MB。那么下一次 GC 启动的阈值是 5MB * 200% = 10MB。 值越小，GC 越勤快，内存占用越低，但 CPU 消耗越高。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 static void setpause (global_State *g) { l_mem threshold, debt; l_mem estimate = g-\u0026gt;GCestimate / 100; // 获取估算内存 l_mem pause = (g-\u0026gt;gcpause != 0) ? g-\u0026gt;gcpause : 200; // 默认 200 /* 计算我们要等待多少内存分配 */ threshold = (pause * estimate); /* 设置债务 = 估算值 - 阈值 因为 阈值 通常 \u0026gt; 估算值，所以这里 debt 是负数 */ debt = gettotalbytes(g) - threshold; luaE_setdebt(g, debt); } stepmul (步进倍率) 含义：控制 GC 扫描的速度。默认值 200(200%)。 逻辑：分配了 1 字节内存（增加了 1 字节债务）,GC 需要执行等同于 2 字节内存的工作量，才能把这 1 字节的债务“抵消”掉。 如果你发现内存飙升得比 GC 回收得快（Alloc \u0026gt; Free），说明 GC 跑慢了，需要调大 stepmul。 如果你发现游戏明显卡顿，可能是 GC 一次步进占用 CPU 太多，尝试调小 stepmul 让切片更细。 ","date":"2024-02-05T18:00:00+08:00","permalink":"/WBlog/p/lua-gc/","title":"Lua GC"},{"content":"核心数据结构 Lua Table 的高效由其底层的 struct Table 决定。从源码中我们可以清晰地看到，它并非单纯的哈希表，而是数组与哈希表的结合体。\nTable 结构体定义 1 2 3 4 5 6 7 8 9 10 11 typedef struct Table { CommonHeader; lu_byte flags; /* 1\u0026lt;\u0026lt;p means tagmethod(p) is not present (元方法缓存) */ lu_byte lsizenode; /* 哈希表长度的对数，即 hash_size = 2^lsizenode */ unsigned int alimit;/* 数组部分的“逻辑”大小 (即 sizearray) */ TValue *array; /* 数组部分指针 */ Node *node; /* 哈希桶数组起始指针 */ Node *lastfree; /* 指向哈希部分最后一个空闲位置，用于快速插入 */ struct Table *metatable; /* 元表 */ GCObject *gclist; } Table; 设计解读：\n双重存储：array 指针管理连续内存，用于存放整数键（1..n）；node 指针管理哈希桶，用于存放其他键或离散的整数键。 空间换时间：lastfree 指针的设计非常巧妙，它避免了每次插入时线性扫描寻找空位，将查找空闲位置的复杂度尽量降低。 lsizenode：哈希表的大小始终保持为 2 的幂次，这里存储的是幂次（log2），省去了存储实际大小的内存，计算时位移即可。 节点（Node）与键（Key） 哈希部分的节点结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 typedef union TKey { struct { TValuefields; struct Node *next; /* 链表法解决冲突，指向下一个冲突节点 */ } nk; TValue tvk; } TKey; typedef struct Node { TValue i_val; TKey i_key; } Node; 这里 Node 包含了 Key 和 Value。Key 是一个 union，为了内存对齐和访问效率，当发生哈希冲突时，通过 next 指针形成单向链表。\n键的归属：数组还是哈希？ 当我们执行 t[k] = v 时，Lua 是如何决定把数据存在 array 还是 node 里的？\n整数键的“VIP 通道” 一般情况下，正整数键（如 t[1], t[100]）会优先尝试放入数组部分。但并非所有整数都会进入数组，必须满足利用率原则。\n核心规则：包含当前 key 的区间 $[1, 2^n]$ 内，非空元素数量必须大于 $2^{n-1}$（即利用率 \u0026gt; 50%）。\n源码 (ltable.c)： Lua 通过 computesizes 函数来计算数组的最佳大小，代码清晰地展示了“\u0026gt; 50%”的判断逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 计算数组部分的最佳大小 */ static unsigned int computesizes (unsigned int nums[], unsigned int *narray) { int i; unsigned int twotoi; /* 2^i */ unsigned int a = 0; /* 统计小于 2^i 的元素个数 */ unsigned int na = 0; /* 最终落入数组部分的元素个数 */ unsigned int optimal = 0; /* 最佳数组大小 */ /* 循环遍历每个 2^i 区间 */ for (i = 0, twotoi = 1; twotoi/2 \u0026lt; *narray; i++, twotoi *= 2) { if (nums[i] \u0026gt; 0) { a += nums[i]; if (a \u0026gt; twotoi/2) { /* 核心判断：利用率 \u0026gt; 50% */ optimal = twotoi; na = a; } } } *narray = optimal; return na; } 举个例子： 如果你创建了一个表 t = {[1]=1, [1000]=1}。\n1 在数组部分。 1000 虽然是整数，但如果强行扩容数组到 1000，中间会有 998 个空洞，不满足 a \u0026gt; twotoi/2。因此，1000 会被当作普通 Key 扔进哈希部分。 哈希部分的“收容所” 以下情况 Key 会进入哈希表：\n非整数类型：字符串、Table、Userdata 等。 越界的整数：数值极大，或者像上面提到的过于稀疏的整数。 负数。 冲突解决：Brent\u0026rsquo;s Method 的变种 这是 Lua Table 实现中最“骚”的操作之一。\n通常哈希表解决冲突用的是开链法（Open Addressing with Chaining），但 Lua 为了节省内存，并没有在这个链表之外单独分配内存，而是直接利用哈希桶数组中未被使用的槽位。\n插入逻辑（Insert） 当我们要插入一个新的 Key (new_key)，算出它应该在的位置 main_pos，却发现那里已经有“人”了 (old_node)，Lua 会根据 old_node 的身份采取不同策略。\n源码 (luaH_newkey)：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 /* 插入新键的核心逻辑 (简化版) */ TValue *luaH_newkey (lua_State *L, Table *t, const TValue *key) { Node *mp; if (ttisnil(key)) luaG_runerror(L, \u0026#34;table index is nil\u0026#34;); /* 1. 计算主位置 (Main Position) */ mp = mainposition(t, key); /* 2. 如果主位置已被占用 */ if (!ttisnil(gval(mp)) || mp == dummynode) { Node *othern; /* 获取空闲位置 (lastfree) */ Node *f = getfreepos(t); if (f == NULL) { /* 没位置了？扩容 */ rehash(L, t, key); return luaH_set(L, t, key); } /* 计算占位者(old_node)原本该在的主位置 */ othern = mainposition(t, keyfromval(mp)); if (othern != mp) { /* Case A: 鸠占鹊巢 -\u0026gt; 把 old_node 赶到 free pos */ while (othern + gnext(othern) != mp) othern += gnext(othern); /* 找到指向 mp 的前驱 */ gnext(othern) = cast_int(f - othern); /* 修正链表指向新位置 f */ *f = *mp; /* 搬迁数据 */ /* 腾出 mp 给新键，因为 mp 是新键的主位置 */ gnext(mp) = 0; setnilvalue(gval(mp)); } else { /* Case B: 原住民冲突 -\u0026gt; 新键只能去 free pos */ if (gnext(mp) != 0) gnext(f) = cast_int((mp + gnext(mp)) - f); /* 头插法：链在 mp 后面 */ else gnext(f) = 0; gnext(mp) = cast_int(f - mp); mp = f; } } setnodekey(L, \u0026amp;mp-\u0026gt;i_key, key); return gval(mp); } 情况 A：鸠占鹊巢 如果 old_node 是被挤到这里的（即 othern != mp）。 操作：Lua 把它挪到 lastfree，把 main_pos 抢回来给 new_key。 目的：保证 new_key 这种“原住民”能直接找到位置，减少后续查找的开销。 情况 B：原住民冲突 如果 old_node 本来就该待在这里。 操作：new_key 去 lastfree，并链接在 old_node 后面。 这种机制被称为 Chained Scatter Table，它充分利用了数组空间，避免了由于大量微小对象分配导致的内存碎片。\n动态扩容：Rehash 的艺术 Table 的空间不是固定的。当空间不足或利用率失衡时，会触发 Rehash。\n触发时机 插入新键且空间已满：当我们赋值一个新键，而 Table 既没有数组空间，也没有哈希空位时。 注意：将某个 Key 置为 nil 不会立即触发 Rehash（为了防止频繁的内存抖动）。只有在空间不足需要重新评估时，才会回收 nil 占用的空间。 Rehash 的三部曲 Rehash 是一个相对昂贵的操作，Lua 必须一次性重新计算数组和哈希两部分的最佳大小。\n统计（Counting）： 遍历整个 Table（包括现有的 Array 和 Hash 部分），统计所有正整数键的数量，并按 $2^n$ 的区间（1-2, 3-4, 5-8\u0026hellip;）进行分桶统计。同时统计非整数键的总数。 定界（Sizing）： 计算数组部分的最佳大小 sizearray。 算法：找到最大的 $N$（$2$ 的幂），使得 $[1, N]$ 区间内的整数键数量 $\\ge N/2$。 凡是小于等于 $N$ 的整数放入新数组，其余放入新哈希表。 搬迁（Relocation）： 申请新的 Array 和 Hash 内存块。 将数据搬运过去（重新计算哈希值）。 释放旧内存。 这解释了为什么 Lua Table 既能像 C 数组一样紧凑高效，又能像 Python Dict 一样灵活。\n迭代器的秘密：pairs 与 ipairs 我们在写 Lua 时常用的两种遍历方式，其底层性能差异巨大。\nipairs：序列专用 ipairs 是为**序列（Sequence）**量身定做的。\n逻辑：维护一个内部计数器 i，从 1 开始递增。 寻址：Lua 内部会先判断 i 是否在 array 的范围内。 源码 (luaH_getint)： 这是整数查找的入口函数，清晰展示了“先查数组，再查哈希”的逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const TValue *luaH_getint (Table *t, lua_Integer key) { /* 1. 数组部分快速查找 (Fast Path) */ /* 这里的 alimit 就是数组的逻辑大小 */ if (l_castS2U(key) - 1 \u0026lt; t-\u0026gt;alimit) return \u0026amp;t-\u0026gt;array[key - 1]; else { /* 2. 哈希部分查找 (Slow Path) */ Node *n = hashint(t, key); for (;;) { if (ttisinteger(gkey(n)) \u0026amp;\u0026amp; ivalue(gkey(n)) == key) return gval(n); /* 找到了 */ else { int nx = gnext(n); if (nx == 0) break; n += nx; /* 沿着冲突链查找 */ } } return luaO_nilobject; } } 在范围内：直接通过指针偏移 array[i] 读取，这几乎就是 C 语言访问数组的速度，极快。 不在范围内：才去查 Hash 表。 pairs：全量遍历 pairs 使用的是 lua_next 函数。\n流程： 先遍历数组部分：从下标 0 到 sizearray 线性扫描。 再遍历哈希部分：从哈希桶的第一个位置扫描到最后一个位置。 顺序问题： 对于纯数组表（如 {10, 20, 30}），因为只扫描数组部分，输出看起来是有序的。 一旦涉及哈希部分，顺序就是乱序的。这是因为 Key 在哈希表中的物理位置取决于 Hash 算法和冲突时的插入顺序，与逻辑顺序无关。 不要依赖 pairs 的遍历顺序，除非你确认表是纯数组且尚未发生过复杂的 Rehash。\n","date":"2024-02-05T18:00:00+08:00","permalink":"/WBlog/p/lua-table/","title":"Lua Table"},{"content":"很幸运生活在一个技术爆炸的时代, 感觉未来充满着可能性\n在这里展示我的生活, 我的思考, 我的成长\n","date":"2024-01-29T00:00:00Z","permalink":"/WBlog/p/hello-world/","title":"hello world"}]