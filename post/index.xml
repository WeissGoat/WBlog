<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 白山羊</title><link>https://WeissGoat.github.io/WBlog/post/</link><description>Recent content in Posts on 白山羊</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 08 Feb 2026 18:32:29 +0800</lastBuildDate><atom:link href="https://WeissGoat.github.io/WBlog/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Lua 分代 GC</title><link>https://WeissGoat.github.io/WBlog/p/lua-%E5%88%86%E4%BB%A3-gc/</link><pubDate>Sun, 08 Feb 2026 18:32:29 +0800</pubDate><guid>https://WeissGoat.github.io/WBlog/p/lua-%E5%88%86%E4%BB%A3-gc/</guid><description>&lt;p&gt;Lua 5.4 引入的&lt;strong&gt;分代垃圾回收（Generational GC）&lt;/strong&gt;,相比于 Lua 5.3 的增量式 GC 专注于“降低停顿时间（Latency）”，Lua 5.4 的分代 GC 旨在解决“高吞吐量（Throughput）”场景下的性能瓶颈。特别是对于那些每一帧都产生大量临时对象（Short-lived objects）的游戏或高并发服务，分代 GC 能带来巨大的性能提升。&lt;/p&gt;</description></item><item><title>Lua GC</title><link>https://WeissGoat.github.io/WBlog/p/lua-gc/</link><pubDate>Mon, 05 Feb 2024 18:00:00 +0800</pubDate><guid>https://WeissGoat.github.io/WBlog/p/lua-gc/</guid><description>&lt;h1 id="lua-gc-三色标记增量回收与写屏障"&gt;Lua GC ：三色标记、增量回收与写屏障
&lt;/h1&gt;&lt;h2 id="从-stop-the-world-到增量"&gt;从 Stop-the-World 到增量
&lt;/h2&gt;&lt;h3 id="lua-50简单的代价"&gt;Lua 5.0：简单的代价
&lt;/h3&gt;&lt;p&gt;在 Lua 5.0 时代，GC 算法非常朴素：&lt;strong&gt;双倍阈值，全量回收&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;逻辑&lt;/strong&gt;：当内存使用量达到上次 GC 后的两倍时，虚拟机暂停所有业务逻辑，跑一遍完整的“标记-清除”。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;后果&lt;/strong&gt;：这就是著名的 &lt;strong&gt;Stop-the-World (STW)&lt;/strong&gt;。如果你的 Lua 内存占用了 1GB，GC 触发的那一瞬间，整个游戏或服务可能会卡顿几百毫秒甚至更久。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="lua-51三色增量标记tri-color-incremental-mark--sweep"&gt;Lua 5.1+：三色增量标记（Tri-color Incremental Mark &amp;amp; Sweep）
&lt;/h3&gt;&lt;p&gt;为了解决卡顿，Lua 5.1 引入了增量 GC。GC 过程与业务代码交替运行。&lt;/p&gt;</description></item><item><title>Lua Table</title><link>https://WeissGoat.github.io/WBlog/p/lua-table/</link><pubDate>Mon, 05 Feb 2024 18:00:00 +0800</pubDate><guid>https://WeissGoat.github.io/WBlog/p/lua-table/</guid><description>&lt;h2 id="核心数据结构"&gt;核心数据结构
&lt;/h2&gt;&lt;p&gt;Lua Table 的高效由其底层的 &lt;code&gt;struct Table&lt;/code&gt; 决定。从源码中我们可以清晰地看到，它并非单纯的哈希表，而是&lt;strong&gt;数组&lt;/strong&gt;与&lt;strong&gt;哈希表&lt;/strong&gt;的结合体。&lt;/p&gt;
&lt;h3 id="table-结构体定义"&gt;Table 结构体定义
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;typedef struct Table {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; CommonHeader;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; lu_byte flags; /* 1&amp;lt;&amp;lt;p means tagmethod(p) is not present (元方法缓存) */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; lu_byte lsizenode; /* 哈希表长度的对数，即 hash_size = 2^lsizenode */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; unsigned int alimit;/* 数组部分的“逻辑”大小 (即 sizearray) */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; TValue *array; /* 数组部分指针 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; Node *node; /* 哈希桶数组起始指针 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; Node *lastfree; /* 指向哈希部分最后一个空闲位置，用于快速插入 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; struct Table *metatable; /* 元表 */
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; GCObject *gclist;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;} Table;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;strong&gt;设计解读：&lt;/strong&gt;&lt;/p&gt;</description></item><item><title>hello world</title><link>https://WeissGoat.github.io/WBlog/p/hello-world/</link><pubDate>Mon, 29 Jan 2024 00:00:00 +0000</pubDate><guid>https://WeissGoat.github.io/WBlog/p/hello-world/</guid><description>&lt;p&gt;很幸运生活在一个技术爆炸的时代, 感觉未来充满着可能性&lt;/p&gt;
&lt;p&gt;在这里展示我的生活, 我的思考, 我的成长&lt;/p&gt;</description></item></channel></rss>